<meta charset='utf-8'/>
<html>
<body>       The distinctions between compile time and runtime are significant, and sometimes confusing. Typically, the computations that occur at runtime are dependent upon the computations performed at compile time, but the reverse is not true. That is, compile time computations do not depend on runtime computations.
    </p>
    <p>
        Bootstrapping a compiler is a monumental achievement. It requires creating a system where the compile time computations are identical to the runtime computations. This creates a cycle in the dependency digraph. While making a dependency digraph strong is difficult to achieve, it demonstrates that the differences between runtime computations and compile time computations can be reduced to zero.
    </p>
    <p>
        Following this, the distinctions between compile time and runtime become less relevant. The only distinction to be made from here is that some computations can be performed now (which may mean statically, at “compile time”), and some cannot. If the runtime environment maintains the strong digraph then programs can perform any task that the original toolchain could, including self modification. It becomes clear that it is desirable to bootstrap the entire toolchain. At the very least, the toolchain must be capable of taking the source code of the entire toolchain and building itself.
    </p>
    <h2>
        <a name="TOC-Advantages">
        </a>
        Advantages
    </h2>
    <ul>
        <li>
            Improves upon Eval using homoiconicity and first-class concepts (code is data)
        </li>
        <li>
            Mutable introspection
        </li>
        <li>
            Profile-guided optimization occurs at runtime.
        </li>
        <li>
            The number of nodes in a programs dependency graph is unbounded, and can become as interconnected or modular, as complex or as simple as desired, but is always strong because all nodes connect to the runtime.
        </li>
        <li>
            Moving up and down levels up abstraction does not break the strong property.
        </li>
    </ul>
    <h2 style="line-height:1.38;margin-top:10pt;margin-bottom:0pt">
        <a name="TOC-Disadvantages">
        </a>
        Disadvantages
    </h2>
    <ul>
        <li>
            The requirement for the digraph to be strong makes it more difficult to design, build and maintain.
        </li>
        <li>
            Complicated security requirements
        </li>
    </ul>
    <p>
        Note that if the runtime is internally transparent and mutable, meaning that all code and data for the runtime can be read and written by the runtime, then it can build copies of itself from its own introspection.
    </p>
    <h2>
        <a name="TOC-Optimization-Time">
        </a>
        Optimization Time
    </h2>
    <div>
        Optimization is usually done during compile time. In plange, optimization is done whenever possible. A program can be executed by the plange interpreter, or it can be compiled. This decision can be made at runtime. To permit the highest level of flexibility, distributables may include an interpretable representation of the program. This enables the runtime to maintain the strongly connected digraph in deployment environments. A side affect of this arrangement is that dynamic recompilation can be performed (permitting full dependency injection support) and enhanced profile guided optimizations are enabled. Notably, since the optimizations may be performed at run time, there may be a "warm up" period before sustained performance is achieved. The runtime may be permitted to cache optimized binaries to alleviate warm up.
    </div>
    <p>
        See also:
        <a href="first-classing.html">
            First Classing
        </a>
        <br>
        </br>
    </p>
</body>
</html>
