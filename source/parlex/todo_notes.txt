âˆ…, the empty set
ğ•€, the integers
â„•, the natural numbers, the non-negative integers
ğ•, the whole numbers, the positive integers
ğ”¹, the booleans, { true, false }
ğ’«, the power set
ÊŠ: X â†’ {Îµ} âˆª X, the function adding the "empty" element to a set
âŠ•: â„• â†’ ğ’«(â„•), the sequence function âŠ•(x) â†¦ { y : y âˆˆ â„• âˆ§ y < x }
	e.g.	âŠ•(0) = {}
	e.g.	âŠ•(3) = {0, 1, 2}



n âˆˆ â„•, the length of the input document
P := âŠ•(n), the set of positions within the input document



X, the set of arbitrary constants
	This metadata is used in algorithms adjacent to the algorithm evaluated here
Î£, the set of "recognizers"
	âˆ€Ïƒ âˆˆ Î£
		Ïƒ: P â†’ ğ’«(ğ•), a function taking a document position as input, and returning the matched substring lengths
T, the set of "terminals", a specialization of recognizers
	âˆ€t âˆˆ T
		t.Î” âˆˆ â„•, the length in characters
		t.f: P â†’ ğ”¹, the test function	
		t(p) â†¦ f(p) ? { Î” } : âˆ…
			To satisfy P â†’ ğ’«(ğ•)
	i.e.:
		string literals
		character classes where t.Î” = 1
A, the set of "state machines", a specialization of recognizers
	âˆ€a âˆˆ A
		a.k âˆˆ ğ•, the number of states
		a.Î´ : âŠ•(a.k)Ã—(Î£Ã—X) â†’ âŠ•(a.k), the transition function
		a.w0 âˆˆ âŠ•(a.k), the start state
		a.f âˆˆ âŠ•(a.k) âˆ§ 0 < f, the number of accept states such that states {a.k-1, a.k-2, ... a.k-f} are accept states
		***the definition of a(p) is deferred***



Î£ = T âˆª A
Ïƒ := |Î£|, the number of recognizers used by the grammar
We assign an arbitrary sequential ordering to the alphabet to achieve constant-time lookups.
L := âŠ•(Ïƒ), L â†” Î£, the set of unique identifiers of elements of Î£
L' : L â†’ Î£, the function mapping an unique integer to an element of Î£

K, the set of "tokens"
	âˆ€k âˆˆ K
		k.l âˆˆ L, the recognizer id, referencing a terminal, to find a match for
		k.p âˆˆ P, the document position to try to find a match for k.l
		k.r âˆˆ ğ”¹, whether the terminal was matched
		
S, the set of "subjobs"
	âˆ€s âˆˆ S
		s.l âˆˆ L, the recognizer id, referencing a state machine, to find matches for
		s.p âˆˆ P, the document position to try to find matches for s.l
		s.C, the set of contexts for this subjob
			âˆ€c âˆˆ s.C
				c.Ïˆ âˆˆ P, the document read head
				c.Ï† âˆˆ E(s.Î˜), the prior context if any	
				c.t âˆˆ E(PÃ—Î£Ã—â„•), the match that produced this DFA configuration
				c.x âˆˆ X, the leaf that corresponds to the transition that produced this DFA configuration
				

Subjobs and tokens are created and inserted into S and K on demand, respectively. Each subjob is uniquely identified by PÃ—L, and is retrieved using this identifier.

R = K âˆª S
M: PÃ—L â†’ ÊŠ(R), a two dimensional array sparsly populated with the elements of R.
M': PÃ—L â†’ R, an imperative function populating M as needed.
	

Z := PÃ—A, the set of possile subjob identifiers
|Z| = nÃ—|A|, the worst-case space complexity of subjobs

	

Z' âŠ† Z, the subjobs actually instantiated
S : P
A subjob (p, l) is instantiated iff either:
	1. l is the root DFA of the grammar and p = 0, or
	2. a DFA (k, Î´, q0, f) and 

A subjob may produce multiple matches of the form PÃ—LÃ—â„•, representing the recognition of a given symbol, at a given document position, and consuming a finite number of characters within the document.

total subscription count <= n*|A|*max(size of domain of Î´)

Total work item count <= n*|A|*(total subscription count)
Total terminal match count <= n*|T|

An array of atomic RMW pointers of dimensions stores

M := ZÃ—ğ•, The set of possible "matches" indicating the document position, the recognizer that matched, and the number of consumed characters
C: E(C)Ã—PÃ—MÃ—(

C: L â†’ 

C : P*L â†’   is the set of DFA contexts of a subjob z âˆˆ Z

The possible children of context c(x,z,h,l), D(x,z,h,l) = { c(y,z,i,m) | âˆ€y âˆˆ I âˆ§ âˆ€m âˆˆ Q(p) âˆ§ x < y âˆ§ i = c(x,z,h,l)::h }

The possible ancestors of context c(x,z,h,l), H(x,z,h,l) = { c(y,z,i,m) | c(x,z,h,l) âˆˆ D(y,z,i,m) }

DFA contexts owned by subjob z, C(z) = { c(x,z,h,l) | âˆ€x âˆˆ I âˆ§ h âŠ† C(z)* âˆ§ z(i, p) = z âˆ§ l âˆˆ Q(p) };

The first context created by a subjob:
	c(i,z(i,p),{}*,q0(p))

No transition can match the null string, and each transition creates a child context that must have a later document position. Therefore:
âˆ€c(x,z,h,l) âˆˆ C(z), z(i,p) = z, |h| <= i âˆ§ | c(x,z,h,l) | <= n - x

Or differently,
	âˆ€z âˆˆ Z, | C(z) | < âˆ

Thus:
	| { c | âˆ€c âˆˆ C(z), âˆ€z âˆˆ Z } | < âˆ
Which proves termination
