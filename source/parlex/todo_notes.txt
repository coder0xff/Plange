∅, the empty set
𝕀, the integers
ℕ, the natural numbers, the non-negative integers
𝕎, the whole numbers, the positive integers
𝔹, the booleans, { true, false }
𝒫, the power set
ʊ: X → {ε} ∪ X, the function adding the "empty" element to a set
⊕: ℕ → 𝒫(ℕ), the sequence function x ↦ { y : y ∈ ℕ ∧ y < x }
	e.g.	⊕(0) = {}
	e.g.	⊕(3) = {0, 1, 2}
U*, the union across sets
max*, the maximum value across values

-------------------------------------------------------------------------------------------------

n ∈ ℕ, the length of the input document
P := ⊕(n), the set of positions within the input document

-------------------------------------------------------------------------------------------------

X, the set of arbitrary constants
	This metadata is used in algorithms adjacent to the algorithm evaluated here
	
Σ, the set of "recognizers"
	∀σ ∈ Σ
		σ: P → 𝒫(𝕎), a function taking a document position as input, and returning the matched substring lengths
		
T, the set of "terminals", a specialization of recognizers
	∀t ∈ T
		t.Δ ∈ ℕ, the length in characters
		t.f: P → 𝔹, the test function	
		t(p) = f(p) ? { Δ } : ∅
			To satisfy P → 𝒫(𝕎)
	i.e.:
		string literals
		character classes where t.Δ = 1
		
A, the set of "state machines", a specialization of recognizers
	∀α ∈ A
		α.k ∈ 𝕎, the number of states
		α.δ : ⊕(α.k)×(Σ×X) → ⊕(α.k), the transition function
		α.w0 ∈ ⊕(α.k), the start state
		α.f ∈ ⊕(α.k) ∧ 0 < f, the number of accept states such that states {α.k-1, α.k-2, ... α.k-f} are accept states
		***the definition of α(p) is deferred***

-------------------------------------------------------------------------------------------------

Σ = T ∪ A
β ∈ Σ, the "root" recognizer of the grammar
σ := |Σ|, the number of recognizers used by the grammar

We assign an arbitrary sequential ordering to the alphabet to achieve constant-time lookups.
	L := ⊕(σ), L ↔ Σ, the set of unique identifiers of elements of Σ
	L' : L → Σ, the function mapping an unique integer to an element of Σ

-------------------------------------------------------------------------------------------------

Each "producer" is uniquely identified by P×L, and is retrieved using this identifier achieving constant time lookup.
Z := P×L, the set of possile producer identifiers
|Z| = n×σ, the worst-case space complexity of producers
M': Z → ʊ(R), a two dimensional array sparsly populated by the elements of R.
M: Z → R, an imperative function populating M' as needed.
β' := M((0, β)), the root producer, i.e. the root recognizer at document position 0
H := Z×𝕎, the set of possible "matches", each indicating a substring that was successfully parsed

R, the set of possible "producers"
	∀r ∈ R
		r.p ∈ P, the document position to try to find matches for r.l
		r.l ∈ L, the recognizer id to find a match for
		r.o ∈ 𝒫(𝕎), the matched substring lengths, which is constructed one element at a time during execution
		r.Y, the set of subcriptions
			∀y ∈ Y
				y.z ∈ Z, the subscribed consumer
				y.c, a context (defined later)
				y.x ∈ X, a leaf
				
				

K, the set of possible "tokens", a specialization of producers
	∀k ∈ K
		k.l ∈ L, the recognizer id, referencing a terminal, to find a match for
		k.p ∈ P, the document position to try to find a match for k.l		
		k.o ∈ 𝒫(𝕎) ∧ 0 <= |k.o| <= 1, the matched substring lengths

S, the set of possible "subjobs", a specialization of producers (subjobs are also "consumers")
	∀s ∈ S
		s.l ∈ L, the recognizer id, referencing a state machine, to find matches for
		s.p ∈ P, the document position to try to find matches for s.l
		s.o ∈ 𝒫(𝕎), the matched substring lengths
		s.C, the set of "contexts" for this subjob (a snapshot of a state-machine evaluation)
			∀c ∈ s.C
				c.ψ ∈ P, the document read head
				c.φ ∈ E(s.Θ), the prior context, if any	
				c.t ∈ E(H), the match that produced this DFA configuration, if any
				c.x ∈ E(X), the leaf that corresponds to the transition that produced this DFA configuration, if any

R = K ∪ S, the set of possible "producers"
r0 ∈ R, the "root" recognizer, which the entire document will be parsed on

-------------------------------------------------------------------------------------------------

A recognizer M((p, l)) is instantiated iff either
	M((p, l)) = β', or		
	∃α ∈ A, ∃w ∈ ⊕(α.k), ∃s ∈ S, ∃c ∈ s.C, c.ψ = p ∧ α.δ(s, w) ∈ ⊕(α.k) 
		A recognizer is only created if a state machine "asks" for it as a transition symbol.

M((p, l)) is always instantiated and "seeds" the parsing algorithm.

-------------------------------------------------------------------------------------------------

D, the set of work items, which are only applicable to subjob processing (implemented as a concurrent queue though)
	∀d ∈ D
		d.z ∈ Z, the producer identifier, which references a subjob
		(p, l) = d.z (for convenience of notation)
		d.c ∈ M(d.z).C, the context
		d.s ∈ ⊕(L'(M(d.z).l).k), the state in the state-machine
		
		When a work item is processed, the domain of the transition function Q, of the specified state-machine is enumerated.
			α = L'(M(d.z).l), the referenced state machine
			( Recall the definition of A where α.δ : ⊕(α.k)×(Σ×X) → ⊕(α.k) )
			Q := { (q, x) : q ∈ Σ, x ∈ X, α.δ(d.s, (q, x)) ∈ ⊕(a.k) }, the symbols and metadata of out edges from the state
				∀(q, x) ∈ Q
					r = M((p, q)) ∈ R (the producer at document position p, and recognizer q)
					y ∈ r.Y, add a subscription element into the target producer
						y.z = d.z
						y.c = d.c
						y.x = x
							
∀r ∈ R, for each producer
	Upon matching some substring of length l, create new work items from subscriptions
		∀y ∈ r.Y, for each subscription	
			d ∈ D, add work item
			d.z = y.z			
			d.c.ψ = r.p + l
			d.c.φ = y.c
			d.c.t = ((r.p, r.l), n)
			d.c.x = y.x
			
The above describes a producer-consumer system wherein matching a substring creates new work items depending on said substring, and the work items in turn yield additional match substrings. This affect propogates from the leaf nodes of the document syntax to the root node (assuming the document satisfies the grammar). Notably, the dependency graph is generated top down resembling an LL parser, but the events bubble up from the bottom like an LR parser. The work queue lends itself to asymptotic analysis. That is, an upper bound on the work items that will be submitted is an upper bound of the execution time. By recursively expanding the terms within a work item, we produce a description of the items in D.

The items in D are dependent on the individual elements wihtin A. To simplify analysis we substitute a fictitious "worst" state machine , ω, for each of those elements.

	
	ω.k = max(α.k), ∀α ∈ A
	ω.δ, 
	
	









total subscription count <= n*|A|*max(size of domain of δ)

Total work item count <= n*|A|*(total subscription count)
Total terminal match count <= n*|T|

An array of atomic RMW pointers of dimensions stores

M := Z×𝕎, The set of possible "matches" indicating the document position, the recognizer that matched, and the number of consumed characters
C: E(C)×P×M×(

C: L → 

C : P*L →   is the set of DFA contexts of a subjob z ∈ Z

The possible children of context c(x,z,h,l), D(x,z,h,l) = { c(y,z,i,m) | ∀y ∈ I ∧ ∀m ∈ Q(p) ∧ x < y ∧ i = c(x,z,h,l)::h }

The possible ancestors of context c(x,z,h,l), H(x,z,h,l) = { c(y,z,i,m) | c(x,z,h,l) ∈ D(y,z,i,m) }

DFA contexts owned by subjob z, C(z) = { c(x,z,h,l) | ∀x ∈ I ∧ h ⊆ C(z)* ∧ z(i, p) = z ∧ l ∈ Q(p) };

The first context created by a subjob:
	c(i,z(i,p),{}*,q0(p))

No transition can match the null string, and each transition creates a child context that must have a later document position. Therefore:
∀c(x,z,h,l) ∈ C(z), z(i,p) = z, |h| <= i ∧ | c(x,z,h,l) | <= n - x

Or differently,
	∀z ∈ Z, | C(z) | < ∞

Thus:
	| { c | ∀c ∈ C(z), ∀z ∈ Z } | < ∞
Which proves termination
