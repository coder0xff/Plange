---
#References
#http://math.stackexchange.com/questions/1150746/what-is-the-operator-precedence-for-quantifiers
#http://math.stackexchange.com/questions/266182/order-of-precedence-of-set-operators
#http://math.stackexchange.com/questions/128504/boolean-algebra-operation-precedence
#http://math.stackexchange.com/questions/340425/operator-precedence-for-integer-division

ADD_SUB:
    syntax: >
        EXPRESSION {IC} ("±"|"+-") {IC} EXPRESSION
    assoc: left
    doc: >
        creates an abstract value storing the simultaneous results of addition and subtraction

ADDITION:
    syntax: >
        EXPRESSION {IC} "+" {IC} EXPRESSION
    assoc: either

ALL:
    syntax: >
        ("∀"|"all") {IC} EXPRESSION
    doc: >
        constrain ALL elements of a Collection to be true
    example: |
        someNumbers := {| -100, 1, 100 |};

        if (∀ { x >= 0 | x ∈ someNumbers}) {
            print("None of the numbers are negative");
        } else {
            print("Some of the numbers are negative");
        }
    notes: >
        The values in the collection need not be Bool, so long as Bool casts T is true, where T is the type of each element.
    see:
        - EXISTS
        - EXISTS_ONE

ALLOCATION:
    syntax: >
        "alloc" {IC} PARENTHETICAL_INVOCATION
    doc: >
        create an object on the heap

AND:
    syntax: >
        EXPRESSION {IC} ("∧"|"and") {IC} EXPRESSION
    assoc: either
    precedes: [OR, IMPLICATION, XOR, IFF]

ARGUMENT:
    syntax: >
        EXPRESSION

ARGUMENT_PACK:
    syntax: >
        EXPRESSION {IC} "..."

ARRAY:
    syntax: >
        "[" {IC} [EXPRESSION {{IC} "," {IC} EXPRESSION} {IC} ] "]"

ARRAY_INVOCATION:
    syntax: >
        EXPRESSION "[" [{IC} (ARGUMENT|ARGUMENT_PACK|SLICE)] {{IC} "," [{IC} (ARGUMENT|ARGUMENT_PACK|SLICE)]} {IC} "]"

ASM_EXPRESSION:
    syntax: >
        ASM_IDENTIFIER | ASM_PTR_ARITHMETIC_ATT | ASM_PTR_ARITHMETIC_INTEL | NON_FRACTIONAL

ASM_IDENTIFIER:
    syntax: >
        ["%"] IDENTIFIER

ASM_FUNCTION:
    syntax: >
        [ "(" {IC} [ PARAMETER {{IC} "," {IC} PARAMETER} {IC} ] ")" {IC} ] [FUNCTION_MODIFIER] "asm" {IC} "{" ASM_SCOPE "}"

ASM_OP:
    syntax: >
        (lowercase_letter) {lowercase_letter}

ASM_PTR_ARITHMETIC_ATT:
    syntax: >
        (ASM_IDENTIFIER ":" NON_FRACTIONAL) | (ASM_IDENTIFIER ":" NON_FRACTIONAL ASM_PTR_ARITHMETIC_ATT_REG) | (NON_FRACTIONAL ASM_PTR_ARITHMETIC_ATT_REG)

ASM_PTR_ARITHMETIC_ATT_REG:
    syntax: >
        "(" [ASM_IDENTIFIER] ["," ASM_IDENTIFIER ["," NON_NEG_NON_FRACTIONAL]] ")"

ASM_PTR_ARITHMETIC_INTEL:
    syntax: >
        [("BYTE"|"WORD"|"DWORD"|"QWORD") " PTR"] "[" [ASM_IDENTIFIER ":"] ASM_IDENTIFIER ["+" ASM_IDENTIFIER ["*" NON_NEG_NON_FRACTIONAL]] [("+"|"-") NON_NEG_INTEGER] "]"

ASM_SCOPE:
    syntax: >
        {IC | ASM_STATEMENT}

ASM_STATEMENT:
    syntax: >
        ASM_OP [ICR ASM_EXPRESSION {{IC} "," [{IC} ASM_EXPRESSION]}] {IC} "\n"

ASSIGNMENT_CHAIN:
    syntax: >
        [XML_DOC_STRING {IC}] IDENTIFIER {IC} ("←"|"<-") {IC} (EXPRESSION|ASSIGNMENT_CHAIN)
    precedes: [EXPRESSION, LESSER_CHAIN]
    doc: >
        place the given value(s) into the given variable(s)
    example: |
        iPow2 ← -1;
    notes: |
        <p>The left hand side may not be an lvalue (in C parlance). Rather, some algebras and solvers reduce free variables.</p>
        <div class="code">
            <p>Example</p>
            <pre>x + 1 ← 0;</pre>
        </div>
        <p>Assignment operations can be chained together</p>
        <div class="code">
            <p>Example</p>
            <pre>a ← b ← c;</pre>
        </div>

BIJECTION:
    syntax: >
        EXPRESSION {IC} ("↔"|"<->") {IC} EXPRESSION
    assoc: either
    doc: >
        a bijection exists between the left and right hand operands

BINARY_ARITHMETIC_OP:
    syntax: >
        ADD_SUB | ADDITION | DIVISION | EXPONENTIATION | INTEGER_DIVISION | MODULATION | MULTIPLICATIVE_OP | SHIFTL | SHIFTR | SUBTRACTION
    doc: >
        the collection of binary operators that work on numbers (among other things)

BINARY_COLLECTION_OP:
    syntax: >
        BIJECTION | INTERSECTION | SYMMETRIC_DIFFERENCE | UNION
    doc: >
        binary operators on collections

BINARY_LOGICAL_OP:
    syntax: >
        AND | IFF | IMPLICATION | MAPS_TO | NAND | NOR | OR | XOR

BINARY_OP:
    syntax: >
        BINARY_ARITHMETIC_OP | BINARY_COLLECTION_OP | BINARY_LOGICAL_OP | BITWISE_OP | CONSTRUCTIVE_OP | RELATIONAL_OP
    doc: >
        a sequence of one or more punctuation (and special) characters representing an infix operator
    notes: >
        <h4>* (<a href="/documentation/syntax/MULTIPLICATION.php">multiplication</a>)</h4>
        <ul>
            <li>as the arithmetic operator, multiplication: Number * Number → Number</li>
            <li>as the product of Types, making a tuple Type: Type * Type → Type</li>
            <li>as the the inner product of two vectors as an alternative to <a href="/documentation/syntax/DOT_PRODUCT.php">dot_product</a>: Vector&lt;d, Number&gt; * Vector&lt;d, Number&gt; → Number</li>
            <li>See also: <a href="/documentation/syntax/KLEENE_STAR.php">kleene_star</a></li>
        </ul>

        <h4>× (<a href="/documentation/syntax/CROSS_PRODUCT.php">cross_product</a>)</h4>
        <p>The unicode character MULTIPLICATION SIGN (U+00D7) (not to be confused with x, the unicode character LATIN SMALL LETTER X (U+0078))
        may be typed as <code>_x_</code>.</p>
        <ul>
            <li>as the arithmetic operator "multiplication"</a>
                Function signature: Number * Number → Number
            </li>
            <li>as the cross product of two three component vectors <a href="/documentation/syntax/CROSS_PRODUCT.php">cross_product</a>
                Function signature: Vector&lt;3&gt; * Vector&lt;3&gt; → Vector&lt;3&gt;
            </li>
            <li>as the product of Types, making a tuple Type
                Function signature: Type * Type → Type
            </li>
        </ul>

        <h4>→ (arrow)</h4>
        <p>The unicode character RIGHTWARD ARROW (U+2192) may be typed as <code>-&gt;</code>.
        The arrow operator creates an object which is simultaneously a <b>function type</b>
        and a <a href="/documentation/syntax/MAPS_TO.php">maps_to</a> relation. The signature of a function is composed with the left hand side defining the function's domain (the input parameter types) and the right hand defining the codomain (the return type).</p>
        <ul>
            <li>as a factory of a function type
                Function signature: Type * Type → Type
            </li>
            <li>as a relation indicating a <a href="/documentation/syntax/MAPS_TO.php">maps_to</a> constraint
                Function signature: Set * Set → Relation
            </li>
        </ul>

        <h4>∘ (ring)</h4>
        <p>The unicode character RING OPERATOR (U+2218) may be typed as <code>_o_</code>.
            The ring operator composes functions such that <code>(f ○ g)(x)</code> is equivalent to
            <code>f(g(x))</code>.</p>
        <ul>
            <li>as the <a href="/documentation/syntax/COMPOSITION.php">composition</a> operator
                Function signature: (X → Y) * (Y → Z) → (X → Z)
            </li>
        </ul>

        <h4>& (prepend)</h4>
        <p>The prepend operator creates a new collection, putting the left hand operand at the beginning and then appending the collection in the right hand operand</p>
        <ul>
            <li>as the denumerable constructor <a href="/documentation/syntax/PREPEND.php">prepend</a>
                Function signature: T * Collection&lt;T&gt; -&gt; Collection&lt;T&gt;
            </li>
        </ul>

        <h4>∪ (set_union)</h4>
        <p>The unicode character UNION (0x222A) may be typed as <code>_u_</code>. Not to be confused with 'U' (0x55).</p>
        <ul>
            <li>as the set union
                Function signature: Set * Set → Set
            </li>
        </ul>

        <h4>∩ (set_intersection)</h4>
        <p>The unicode character INTERSECTION (0x2229) may be typed as <code>_i_</code>.
        <ul>
            <li>as the set_intersection operator
                Function signature: Set * Set → Set
            </li>
        </ul>

        <h4>/ (slash)</h4>
        <ul>
            <li>as the collection_difference operator
                Function signature: Collection * Collection → Collection
            </li>
            <li>as the division operator
                Function signature: Number * Number → Number
            </li>
        </ul>

        <h4>⊕ (xor)</h4>
        <p>The unicode character CIRCLED PLUS (0x2295) may be typed as <code>_xor_</code>.</p>
        <ul>
            <li>as the set_symmetric_difference operator
                Function signature: Set * Set → Set
            </li>
            <li>as the xor operator
                Function signature: Bool * Bool → Bool
                Function signature: Integer * Integer → Integer
            </li>
        </ul>

BIT_AND:
    syntax: >
        EXPRESSION {IC} "&&" {IC} EXPRESSION
    assoc: either

BIT_NOT:
    syntax: >
        "~~" {IC} EXPRESSION

BIT_OR:
    syntax: >
        EXPRESSION {IC} "||" {IC} EXPRESSION
    assoc: either

BIT_XOR:
    syntax: >
        EXPRESSION {IC} "^^" {IC} EXPRESSION
    assoc: either

BITWISE_OP:
    syntax: >
        BIT_AND | BIT_OR | BIT_XOR

BLOCK:
    syntax: >
        "{" STATEMENT_SCOPE "}"

BOOL:
    syntax: >
        "true" | "false"
    doc: >
        the two ordinals of the Bool type
    notes: >
        These are included as syntax elements as they are literals, not constants.

BREAK:
    syntax: >
        "break" [({IC} "[" {IC} EXPRESSION {IC} "]") | ({ICR} IDENTIFIER)]
    doc: >
        terminate the containing for, do, or while/until loop
    notes: >
        If a square-bracketed value is appended to a the "break" keyword, that many scope levels plus one will terminate. "break" is the same as "break[0]". If a variable identifier follows the "break" keyword, the iterative flow-control primitive associated with that variable will be affected.
    example: >
        for (i in X) {
            for (j in Y) {
                break i;
            }
        }

CARDINALITY:
    syntax: >
        "#" {IC} EXPRESSION
    precedes: [BINARY_OP]

CAST:
    syntax: >
        PARENTHETICAL {IC} EXPRESSION
    precedes: [BINARY_OP]
    doc: >
        change the type of the specified expression to the parenthesized type

CASTS:
    syntax: >
        EXPRESSION {IC} "casts" {IC} EXPRESSION

CEILING:
    syntax: >
        ("⌈" {IC} EXPRESSION {IC} "⌉") | ( "|'" {IC} EXPRESSION {IC} "'|" )

COMPOUND:
    syntax: >
        EXPRESSION {IC} "|" {IC} EXPRESSION
    assoc: left

COMMENT:
    syntax: >
        "/*" {all} "*/"
    doc: >
        an inline comment

COMPLEMENT:
    syntax: >
        EXPRESSION {IC} "ᶜ"
    precedes: [BINARY_OP]
    doc: >
        the universal set excluding the elements of the collection

COMPOSITION:
    syntax: >
        EXPRESSION {IC} ("∘"|"_o_") {IC} EXPRESSION
    assoc: either
    doc: >
        function composition operator

CONDITIONAL:
    syntax: >
        EXPRESSION {IC} "?" {IC} EXPRESSION {IC} ":" {IC} EXPRESSION
    assoc: right
    doc: >
        ternary conditional
    notes: >
        If the first expression is true then evaluates to the second expression otherwise evaluates to the third expression.

CONSTRUCTIVE_OP:
    syntax: >
        COMPOSITION | COMPOUND | PREPEND | NULL_COALESCE
    doc: >
        operators that are constructive for making values

CONTINUE:
    syntax: >
        "continue" [({IC} "[" {IC} EXPRESSION {IC} "]") | ({ICR} IDENTIFIER)]
    doc: >
        begin the next iteration in the containing for, do, or while/until loop
    notes: >
        If a square-bracketed value is appended to the "continue" keyword, that many scope levels plus one will continue. "continue" is the same as "continue[0]". If a variable identifier follows to the continue keyword, the iterative flow-control primitive associated with that variable is affected.
    example: >
        for (i in X) {
            for (j in Y) {
                continue i;
            }
        }

CROSS_PRODUCT:
    syntax: >
        EXPRESSION {IC} ("×"|"_x_") {IC} EXPRESSION
    assoc: left
    precedes: [DOT_PRODUCT]
    doc: >
        scalar multiplication or Vector<3, N> cross product

DATE:
    syntax: >
        DATE_YEAR_MONTH_DAY | DATE_YEAR_DAY

DATE_YEAR_MONTH_DAY:
    syntax: >
        decimal_digit decimal_digit decimal_digit decimal_digit "-" decimal_digit decimal_digit "-" decimal_digit decimal_digit
    precedes: [SUBTRACTION]
    doc: >
        a date literal

DATE_YEAR_DAY:
    syntax: >
        decimal_digit decimal_digit decimal_digit decimal_digit "-" decimal_digit decimal_digit decimal_digit

DATE_TIME:
    syntax: >
        DATE "T" TIME

DECLARATION:
    syntax: >
        [XML_DOC_STRING {IC}] IDENTIFIER
    doc: >
        declare a variable and optionally assign a value to it
    examples:
        - |
            <Number> x <- 100;
        - |
            <> name <- "Alice"; //implicitly type String
        - |
            object <- {
                "employees":[
                    (|"John", "Doe"|),
                    (|"Anna", "Smith"|),
                    (|"Peter", Jones"|)],
                "contractors":[
                    (|"Matt", "Williams"|)]
            };

            object <- (x) { return x*2; }; //no type constraint
    see:
        - STATEMENT

DEFINITION:
    syntax: >
        [XML_DOC_STRING {IC}] IDENTIFIER {IC} ":=" {IC} EXPRESSION
    doc: >
        define a constant, an alias for the valuation of a specified expression
    example: >
        <Double> almostPi := 355/113;

DELTA:
    syntax: >
        ("Δ"|"_delta_") ["^" WHOLE_NUMBER] EXPRESSION
    precedes: [EXPONENTIATION, BINARY_OP]

DIMENSION:
    syntax: >
        IDENTIFIER | DIMENSIONAL_ANALYSIS_OP
    doc: >
        a dimension used in dimensional analysis

DIMENSIONAL_ANALYSIS_OP:
    syntax: >
        UNIT_DIVISION | UNIT_EXPONENTIATION | UNIT_MULTIPLICATION
    doc: >
        operators in a dimension

DIMENSIONAL_NUMBER:
    syntax: >
        NON_NEG_NUMBER DIMENSION
    precedes: [EXPONENTIATION, BINARY_OP]
    doc: >
        a number with a trailing dimension

DIVISION:
    syntax: >
        EXPRESSION {IC} ("÷"|"/" ) {IC} EXPRESSION
    assoc: left
    precedes: [INTEGER_DIVISION, MODULATION, SUBTRACTION, ADDITION, ADD_SUB]
    doc: >
        division or splits the left hand side collection into a collection of collections each the size of the right hand side

DO:
    syntax: >
        "do" {IC} EXPRESSION [ {IC} ("while"|"until") {IC} PARENTHETICAL ]
    doc: >
        invoke a specified nullary void function (expression) once and then repeatedly while or until the parenthetical evaluates to true (when coerced to bool), unless the optional portion is omitted, in which case the function is invoked indefinitely
    see:
        - LOOP

DOT_PRODUCT:
    syntax: >
        EXPRESSION {IC} ("⋅"|"_dot_") {IC} EXPRESSION
    assoc: left
    doc: >
        scalar multiplication or Vector<D, N> inner product
        
DOWNCASTS:
    syntax: >
        EXPRESSION {IC} "downcasts" {IC} EXPRESSION

EMBEDDED_COMMENT:
    syntax: >
        "/***" EMBEDDED_COMMENT_INTERIOR "***/"
    precedes: [COMMENT]
    doc: >
        a comment bounded by arbirtrarily-sized delimiters
    example: |
        /**** this is an embedded_comment
        ***/ the characters at the start of this line have no affect on this ongoing comment
        Embed blocks of code that themselves contain block comments:
            /* Do the thing */
            thing();
        No problem. Now, lets end this comment. ****/
    notes: >
        This allows for commented code to be safely commented out completely by including a sufficient number of asterisks to serve as an opening and closing delimiter.

EMBEDDED_COMMENT_INTERIOR:
    syntax: >
        PAYLOAD | "*" EMBEDDED_COMMENT_INTERIOR "*"

EMBEDDED_NEWLINE_STRING:
    syntax: >
        "\"\"\"" EMBEDDED_NEWLINE_STRING_INTERIOR "\"\"\""
    precedes: [EMBEDDED_STRING, STRING]

EMBEDDED_NEWLINE_STRING_INTERIOR:
    syntax: >
        ("\n" PAYLOAD "\n") | ("\"" EMBEDDED_NEWLINE_STRING_INTERIOR "\"")

EMBEDDED_STRING:
    syntax: >
         "\"\"\"" EMBEDDED_STRING_INTERIOR "\"\"\""
    precedes: [STRING]
    doc: >
        a string bounded by arbirtrarily-sized delimiters
    example: |
        stringWithDoubleQuotes := """""
        The remainder of this is a string literal, excluding the five quotes at the very end.
        We can use four double quotes, like """", but not 5 which is the number of quotes that
        start this string literal. If a string literal with 100 consecutive double quotes in it
        were desired, we would then use 101 double quotes to start and end the string literal.
        """""
    notes: |
        <p>An embedded_string is similar to a regular string literal of the form:</p>
        <div class="code">
            <p>Typical string literal</p>
            <pre>"hello world"</pre>
        </div>
        <p>except that it permits the text to contain any finite number of double quotes. An embedded_string begins with three or more double quotes followed by a new line character, and ends with a new line character followed by the same number of double quotes. All white spaces, characters, and other bytes between the opening and closing delimiter becomes a string literal.</p>

EMBEDDED_STRING_INTERIOR:
    syntax: >
        PAYLOAD | ("\"" EMBEDDED_STRING_INTERIOR "\"")

END_OF_LINE_COMMENT:
    syntax: >
        "//" {not_newline} "\n"

ENUM:
    syntax: >
        "enum" {IC} ["inheriting" {IC} INHERITANCE_LIST {IC}] ["implementing" {IC} INHERITANCE_LIST {IC}] "{" [ENUM_ELEMENT {{IC} "," {IC} ENUM_ELEMENT}] "}"
    doc: >
        makes a compound type with static members for each of the elements, and each of those elements inherit/implement those specified inheritance list 
        
ENUM_ELEMENT:
    syntax: >
        IDENTIFIER [{IC} ":=" {IC} EXPRESSION]
        
EQUALITY_CHAIN:
    syntax:
        EXPRESSION {IC} EQUALITY_CHAIN_LOOP
    precedes: [GREATER_CHAIN, LESSER_CHAIN, SUBSET_CHAIN, SUPERSET_CHAIN]
    doc: >
        one or more equality relations
    examples:
        - |
            X = Y;
        - |
            X = Y = Z;

EQUALITY_CHAIN_LOOP:
    syntax: >
        "=" {IC} EXPRESSION [{IC} EQUALITY_CHAIN_LOOP]
    precedes: [EXPRESSION]
    see:
        - EQUALITY_CHAIN

EXACTLY:
    syntax: >
        EXPRESSION {IC} "exactly" {IC} EXPRESSION
    
EXISTS:
    syntax: >
        ("∃"|"exists") {IC} EXPRESSION
    doc: >
        a constraint asserting that at least one element of the specified Collection is true
    notes: >
        <p>The values in the collection need not be Bool, so long as <code>Bool casts T</code> is true, where T is the type of each element.<p>
    example: |
        shouldRejectLiquorPurchase := (List<Date> patronBirthdates) {
            return ∃{ x < today() - 21yr | x ∈ patronBirthdates };
        }
    see:
        - EXISTS_ONE
        - ALL

EXISTS_ONE:
    syntax: >
        ("∃!"|"exists!") {IC} EXPRESSION
    doc: >
        a constraint asserting that exactly one element of the specified Collection is true
    see:
        - EXISTS
        - ALL

EXPONENTIATION:
    syntax: >
        EXPRESSION {IC} "^" {IC} EXPRESSION
    assoc: right
    precedes: [DIVISION, INTEGER_DIVISION, MODULATION, MULTIPLICATIVE_OP, SUBTRACTION, ADDITION, ADD_SUB]

EXPRESSION:
    syntax: >
        ALLOCATION | ARRAY | ASM_FUNCTION | BINARY_OP | BOOL | CAST | CEILING | COMPLEMENT | CONDITIONAL | DATE | DATE_TIME | DELTA | DIMENSIONAL_NUMBER | EMBEDDED_STRING | ENUM | EQUALITY_CHAIN | FLOOR | FUNCTION | GREATER_CHAIN | IDENTIFIER | IF | INVOCATION | LESSER_CHAIN | LIST | MAGNITUDE | MAP | MEMBER_ACCESS | NEAREST_INTEGER | NON_NEG_NUMBER | OBJECT | PARENTHETICAL | RANGE | REGEX | SET | SET_COMPREHENSION | STRING | SUBSET_CHAIN | SUPERSET_CHAIN | SWIZZLE | THIS | THIS_FUNC | THIS_TYPE | TIME | TUPLE | TYPE | UNARY_OP | VECTOR_NORM | "null"
    doc: >
        a linearization of an evaluation tree containing constants, variables, operators, invocations, and sub expressions
    notes: >
        null is a literal and so is included in the syntax similarly to true, false and numeric literals (and unlike constants)

FACTORIAL:
    syntax: >
        EXPRESSION {IC} "!"
    precedes: [BINARY_OP]

FLOOR:
    syntax: >
        ( "⌊" {IC} EXPRESSION {IC} "⌋" ) | ( "|_" {IC} EXPRESSION {IC} "_|" )

FOR:
    syntax: >
        "for" {IC} "(" {IC} [ STATEMENT_SCOPE {IC} ] EXPRESSION {IC} ";" {IC} [ ASSIGNMENT_CHAIN {{IC} "," {IC} ASSIGNMENT_CHAIN} {IC} ] ")" {IC} EXPRESSION
    doc: >
        evaluate the second expression repeatedly while the second expression is true, all after evaluating the optional STATEMENT_SCOPE
    examples:
        - |
            for (x ← 0; x < 100; x++) {
                print_line(x);
            };
        -
            annotation: >
                demonstrates the optional statement_scope
            example: |
                spammer := (<UInt> count) {
                    for (count > 0; count--; ) {
                        print("SPAM!!!\n");
                    };
                };
        -
            annotation: >
                more than one statement may be used to initialize, and a blank may be used for the increment expression
            example: |
                mergeSorted := (List<Int> a, List<Int> b) {
                    List<Int> result;
                    <Int>i;
                    <Int>j;
                    for (i ← 0; j ← 0; i < a.count && j < b.count; ) { //blank increment expression
                        if (a[i] < b[j]) {
                            result.add(a[i]);
                            i++;
                        } else {
                            result.add(b[j]);
                            j++;
                        }
                    }
                    for (i < a.count; i++) {
                        result.add(a[i])
                    }
                    for (j < b.count; j++) {
                        result.add(b[j]);
                    }
                    return result;
                }

FOR_COLLECTION:
    syntax: >
        "for" {IC} "(" {IC} (([ (TYPE_DEREFERENCE | IMPLICIT_TYPE_DEREFERENCE) {IC} ] IDENTIFIER ) | EXPRESSION ) {IC} ("in"|"∈") {IC} EXPRESSION {IC} ")" {IC} EXPRESSION
    doc: >
        evaluate the last expression repeatedly while iterating over the elements of the specified Collection
    examples:
        - |
            <> fibArray = [ 0, 1, 1, 2, 3, 5, 8, 13 ];
            for (element ∈ fibArray) {
                print(element);
            }
        - |
            for ((key, value) ∈ myMap) {
                //do something
            }

FREE:
    syntax: >
        "free" {IC} EXPRESSION

FUNCTION_MODIFIER:
    syntax: >
        (FUNCTION_MODIFIER_STABILITY|FUNCTION_MODIFIER_NO_THROW|FUNCTION_MODIFIER_ATOMIC|FUNCTION_MODIFIER_PLATFORM|FUNCTION_MODIFIER_MODEL|FUNCTION_MODIFIER_CALLING_CONVENTION) {IC}
    doc: >
        The FUNCTION_MODIFIER_* rules model: ["stable" | "unstable"] ["no_throw"] ["atomic"] {PLATFORM} ["pure"|"imperative"|"opaque"] with the caveat that there has to be an IC between any modifier and the next (if there is a next)

FUNCTION_MODIFIER_ATOMIC:
    syntax: >
        "atomic" [ICR (FUNCTION_MODIFIER_PLATFORM|FUNCTION_MODIFIER_MODEL|FUNCTION_MODIFIER_CALLING_CONVENTION)]

FUNCTION_MODIFIER_CALLING_CONVENTION:
    syntax: >
        "c_call" | "fast_call" | "cold_call" | "ghc_call" | "hipe_call" | "webkit_js_call" | "any_reg_call" | "preserve_most_call" | "preserve_all_call" | "swift_call" | "cxx_fast_tls_call" | "first_target_call" | "x86_std_call" | "X86_fast_call" | "arm_apcs_call" | "arm_aapcs_call" | "arm_aapcs_vfp_call" | "msp430_intr_call" | "x86_this_call" | "ptx_kernel_call" | "ptx_device_call" | "spir_func_call" | "spir_kernel_call" | "intel_ocl_bi_call" | "x86_64_sysv_call" | "x86_64_win64_call" | "x86_vector_call" | "hhvm_call" | "x86_intr_call" | "avr_intr_call" | "avr_signal_call" | "avr_builtin_call"

FUNCTION_MODIFIER_MODEL:
    syntax: >
        ("pure" | "imperative" | "opaque") [ICR FUNCTION_MODIFIER_CALLING_CONVENTION]

FUNCTION_MODIFIER_NO_THROW:
    syntax: >
        "no_throw" [ICR (FUNCTION_MODIFIER_ATOMIC|FUNCTION_MODIFIER_PLATFORM|FUNCTION_MODIFIER_MODEL|FUNCTION_MODIFIER_CALLING_CONVENTION)]

FUNCTION_MODIFIER_PLATFORM:
    syntax: >
        PLATFORM {ICR PLATFORM} [ICR (FUNCTION_MODIFIER_MODEL|FUNCTION_MODIFIER_CALLING_CONVENTION)]

FUNCTION_MODIFIER_STABILITY:
    syntax: >
        ("stable" | "unstable") [ICR (FUNCTION_MODIFIER_NO_THROW | FUNCTION_MODIFIER_ATOMIC | FUNCTION_MODIFIER_PLATFORM | FUNCTION_MODIFIER_MODEL | FUNCTION_MODIFIER_CALLING_CONVENTION)]

FUNCTION:
    syntax: >
        [ "(" {IC} [ PARAMETER {{IC} "," {IC} PARAMETER} {IC} ] ")" {IC} ] [FUNCTION_MODIFIER] BLOCK
    precedes: [CAST]
    doc: >
        creates a function
    notes: >
        Function objects are invoked using the invocation syntax.

        The atomic, pure, imperative, and opaque keywords influence assumptions that the compiler may make regarding a functions implementation. The pure keyword indicates that the implementation uses only pull semantics, is idempotent, and has no side effects. Additionally, only constants can be read, which includes value (not by reference/pointer values) passed as formal parameters. Any violation of these constraints causes an error to occur. The imperative keyword indicates that the implementation is likely not tractable, and it may interact with memory or hardware in unknown ways. Without either pure or imperative, the implementation is assumed to be push-pull and tractable. If the tool chain determines that this is not the case, it will fall back to imperative behavior. Pure functions are implicitly atomic.
    examples:
        - |
            (a, b) pure { return a * b; }
        - |
            <int → int> factorial := (x) { return x == 0 ? 1 : x * factorial(x - 1); };
        - |
            <Collection<T> → T> head := (a&b) { return a; }
        - | 

GREATER_CHAIN:
    syntax: >
        EXPRESSION {IC} GREATER_CHAIN_LOOP
    doc: >
        one or more greater, greater or equals, or equals relations
    examples:
        - |
            X > Y;
        - |
            X > Y ≥ 0;

GREATER_CHAIN_LOOP:
    syntax: >
        ("="|">"|"=>"|"≥") {IC} EXPRESSION [{IC} GREATER_CHAIN_LOOP]
    precedes: [EXPRESSION]
    see:
        - GREATER_CHAIN

HAS:
    syntax: >
        EXPRESSION {IC} ("∋"|"has") {IC} EXPRESSION
    assoc: left
    doc: >
        the in operator, backward

HEX:
    syntax: >
        "0x" hexadecimal_digit {hexadecimal_digit}
    doc: >
        a hexidecimal number

IC:
    syntax: >
        COMMENT | EMBEDDED_COMMENT | END_OF_LINE_COMMENT | WS
    doc: >
        intermediary content - regions that whitespaces and comments can go

ICR:
    syntax: >
        IC {IC}
    doc: >
        intermediary content that is required

IDENTIFIER:
    syntax: >
        (letter | "_") {letter | number | "_"}
    filter: longest
    doc: >
        text that uniquely identifies a constant or variable within a scope
    notes: |
        <p>The first character must be a letter character. Note that the character groups "letter" and "number" are inclusive of many unicode characters beyond the conventional a-z, A-Z and 0-9. Specifically, all unicode codepoints in a letter or number category may be used in an identifier.</p>
        <p>Examples of valid identifiers:</p>
        <code>
            <ul>
                <li>x</li>
                <li>myVariable</li>
                <li>q4</li>
                <li>Employee</li>
                <li>print_line</li>
                <li>символ</li>
                <li>θ</li>
            </ul>
        </code>

        <p>Non examples:</p>
        <code>
            <ul>
                <li>1stValue</li>
            </ul>
        </code>

IF:
    syntax: >
        "if" {IC} PARENTHETICAL {IC} EXPRESSION {{IC} "elif" {IC} PARENTHETICAL {IC} EXPRESSION} [ {IC} "else" {IC} EXPRESSION ]
    doc: >
        returns the expression corresponding to the first parenthetical that evaluates to true when coerced to a boolean, or the else case if none of them evaluate to true, assuming that the else case is present, otherwise returning void
    example: |
        if (input("What is 1 + 1 ? ") = "2") {
            print("You are correct!");
        } else {
            print("Sorry, you are incorrect.");
        }

IFF:
    syntax: >
        EXPRESSION {IC} ("⇔"|"<=>") {IC} EXPRESSION
    assoc: either
    doc: >
        semantic equivalence

IMPLICATION:
    syntax: >
        EXPRESSION {IC} ("⇒"|"=>") {IC} EXPRESSION
    assoc: right
    precedes: [XOR, IFF]
    doc: >
        implication

IMPLICIT_TYPE_DEREFERENCE:
    syntax: >
        "<" {IC} ">"
    doc: >
        use the type inferred on the right hand side

IMPLEMENTS:
    syntax: >
        EXPRESSION {IC} "implements" {IC} EXPRESSION

IMPORT:
    syntax: >
        "import" {IC} EXPRESSION

IN:
    syntax: >
        EXPRESSION {IC} ("∈"|"in") {IC} EXPRESSION
    assoc: left
    doc: >
        Collection membership
    see:
        - FOR_COLLECTION

INEQUALITY:
    syntax: >
        EXPRESSION {IC} ("≠"|"/=") {IC} EXPRESSION
    assoc: left

INHERITS:
    syntax: >
        EXPRESSION {IC} "inherits" {IC} EXPRESSION

INHERITANCE_LIST:
    syntax: >
         [INHERITANCE_ITEM_PREFIX] EXPRESSION {{IC} "," {IC} [INHERITANCE_ITEM_PREFIX] EXPRESSION}
    doc: >
        see: type

INHERITANCE_ITEM_PREFIX:
    syntax: >
        (VISIBILITY_MODIFIER | VISIBILITY_MODIFIER ICR "diamond" | "diamond") ICR

INTEGER_DIVISION:
    syntax: >
        EXPRESSION {IC} "\\" {IC} EXPRESSION
    assoc: left
    precedes: [SUBTRACTION, ADDITION, ADD_SUB]
    doc: >
        same as ⌊x/y⌋ or collection difference (similar to set difference)

INTERSECTION:
    syntax: >
        EXPRESSION {IC} "∩" {IC} EXPRESSION
    assoc: either
    doc: >
        Collection intersection

INVOCATION:
    syntax: >
        PARENTHETICAL_INVOCATION | ARRAY_INVOCATION | TYPE_INVOCATION
    precedes: [RADICAL, NEGATION, BINARY_OP]
    doc: >
        invoke a function, type-function or array-function
    examples:
        - |
            myMethod(1, x^2, "hello\n", someThing)
        - |
            IntList := List<int>; //List is a type function, IntList is a Type
        - |
            print myArray[4]; //4 is ordered and denumerable, myArray implements RandomlyAccessible
    notes: >
        The < > syntactic variety requires the returned value to be a type (it must implement Type), or a function (it must implement Function) that when invoked results in such a type or function. Note that this definition is deliberately recursive. The [ ] syntactic variety requires that each given "indexer" is some element of an ordered set, such as the natural numbers or enum values, and that the invokee is randomly accessible (implements RandomlyAccessible). Lastly, the angle bracket and square bracket syntax are optional; the behavior is identical to being invoked using parentheses. However, alternate syntax is encouraged whenever such requirements are met and helps to both document and enforce the invariants assumed by the author.

IS:
    syntax: >
        EXPRESSION {IC} "is" {IC} EXPRESSION

KLEENE_STAR:
    syntax: >
        EXPRESSION {IC} "*"
    doc: >
        the free monoid operator
    example:
        all_strings := char*;

LESSER_CHAIN:
    syntax: >
        EXPRESSION {IC} LESSER_CHAIN_LOOP
    doc:
        one or more lesser, lesser or equals, or equals relations
    examples:
        - |
            X < Y;
        - |
            X < Y ≤ 0;

LESSER_CHAIN_LOOP:
    syntax: >
        ("="|"<"|"=<"|"≤") {IC} EXPRESSION [{IC} LESSER_CHAIN_LOOP]
    precedes: [EXPRESSION]
    see:
        - LESSER_CHAIN

LIST:
    syntax: >
        "[|" {IC} [EXPRESSION {{IC} ", " {IC} EXPRESSION} {IC} ] "|]"
    doc: >
        a Collection of items
    examples:
        -
            annotation: >
                the empty list
            example: |
                [| |]
        - |
            [|1, 5, 2, 2, 2|]
        - |
            short_days_of_week := ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

LOCK:
    syntax: >
        "lock" {IC} PARENTHETICAL {IC} BLOCK
            
LOOP:
    syntax: >
        ( "while" | "until" ) {IC} PARENTHETICAL {IC} EXPRESSION
    doc: >
        evaluate an expression repeatedly while or until a parenthetical evaluates to true
    see:
        - DO

MAGNITUDE:
    syntax: >
        "|" {IC} EXPRESSION {IC} "|"
    doc: >
        absolute value, vector magnitude, cardinality

MAP:
    syntax: >
        "{" [{IC} EXPRESSION {IC} ":" {IC} EXPRESSION {{IC} "," {IC} EXPRESSION {IC} ":" {IC} EXPRESSION}] {IC} "}"
    precedes: [FUNCTION]
    doc: >
        create an associative Collection implementing Map<a → b>
    example: |
        { "first": "john", "last": "doe" }
    notes: >
        The element type is constrained to some type that CASTS all the given elements.
    see:
        - CASTS

MAPS_TO:
    syntax: >
        EXPRESSION {IC} ("→"|"->") {IC} EXPRESSION
    assoc: right
    doc: >
        function type builder

MEMBER_ACCESS:
    syntax: >
        EXPRESSION {IC} "." {IC} IDENTIFIER
    assoc: left

MEMBER_OFFSET:
    syntax: >
        "@" {IC} WHOLE_NUMBER

MODULATION:
    syntax: >
        EXPRESSION {IC} "%" {IC} EXPRESSION
    assoc: left
    precedes: [SUBTRACTION, ADDITION, ADD_SUB]
    doc: >
        mod operator or returns a collection containing the elements that would not be consumed from the end of the left hand side by taking the chunk of the right hand side

MULTIPLICATION:
    syntax: >
        EXPRESSION {IC} "*" {IC} EXPRESSION
    assoc: either
    precedes: [MAPS_TO]
    doc: >
        scalar multiplication, cartesian product

MULTIPLICATIVE_OP:
    syntax: >
        CROSS_PRODUCT | DOT_PRODUCT | MULTIPLICATION
    precedes: [INTEGER_DIVISION, MODULATION, SUBTRACTION, ADDITION, ADD_SUB]

NAND:
    syntax: >
        EXPRESSION {IC} "↑" {IC} EXPRESSION
    assoc: left
    precedes: [OR, IMPLICATION, XOR, IFF]

NEAREST_INTEGER:
    syntax: >
        ( "⌊" {IC} EXPRESSION {IC} "⌉" ) | ("|_" {IC} EXPRESSION {IC} "'|" )
    doc: >
        round to the nearest integer

NEGATION:
    syntax: >
        "-" {IC} EXPRESSION
    precedes: [BINARY_OP]
    example: |
        -5

NON_FRACTIONAL:
    syntax: >
        ["-"] NON_NEG_NON_FRACTIONAL

NON_NEG_FRACTIONAL:
    syntax: >
        (decimal_digit {decimal_digit} "." {decimal_digit}) | ("." decimal_digit {decimal_digit})
    doc: >
        a number with a decimal point

NON_NEG_INTEGER:
    syntax: >
        (NON_ZERO_DECIMAL_DIGIT {decimal_digit}) | "0"
    notes: >
        The first digit may not be zero, unless it is the only digit.

NON_NEG_NON_FRACTIONAL:
    syntax: >
        NON_NEG_INTEGER | HEX | OCTAL

NON_NEG_NUMBER:
    syntax: >
        NON_NEG_NON_FRACTIONAL | NON_NEG_FRACTIONAL

NON_ZERO_DECIMAL_DIGIT:
    syntax: >
        "1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"
    doc: >
        used for constructing number

NOR:
    syntax: >
        EXPRESSION {IC} ("↓") {IC} EXPRESSION
    assoc: left
    precedes: [OR, IMPLICATION, XOR, IFF]

NOT:
    syntax: >
        ("¬"|"~") {IC} EXPRESSION
    precedes: [BINARY_OP]
    doc: >
        boolean not

NOT_HAS:
    syntax: >
        EXPRESSION {IC} ("∌"|"/has") {IC} EXPRESSION
    assoc: left
    doc: >
        not_in, backward

NOT_IN:
    syntax: >
        EXPRESSION {IC} ("∉"|"/in") {IC} EXPRESSION
    assoc: left
    doc: >
        Collection anti-membership

NULL_COALESCE:
    syntax: >
        EXPRESSION {IC} "??" {IC} EXPRESSION
    assoc: left
    doc: >
        return the first expression if non-null otherwise return the second expression
    notes: >
        may be chained together

OBJECT:
    syntax: >
        "object" {IC} ["inheriting" {IC} INHERITANCE_LIST {IC}] ["implementing" {IC} INHERITANCE_LIST {IC}] "{" TYPE_SCOPE "}"

OCTAL:
    syntax: >
        "0" octal_digit {octal_digit}
    doc: >
        octal number

OR:
    syntax: >
        EXPRESSION {IC} ("∨"|"or") {IC} EXPRESSION
    assoc: either
    precedes: [IMPLICATION, XOR, IFF]

PARAMETER:
    syntax: >
        PARAMETER_NATURAL | PARAMETER_ANALYTIC
    doc: >
        declares a formal argument of a function
    notes: >
        The last variation accepts an expression, which is then set to be equivalent to the passed in value. This enables pattern matching and solving on parameters.
    see:
        - FUNCTION

PARAMETER_ANALYTIC:
    syntax: >
        EXPRESSION [ {IC} "=" {IC} EXPRESSION ]

PARAMETER_NATURAL:
    syntax: >
        ([ TYPE_DEREFERENCE {IC} ] IDENTIFIER ["..."]) | ([ (TYPE_DEREFERENCE | IMPLICIT_TYPE_DEREFERENCE) {IC} ] IDENTIFIER ["..."] {IC} "=" {IC} EXPRESSION ["..."])
    precedes: [PARAMETER_ANALYTIC]

PARENTHETICAL:
    syntax: >
        "(" {IC} EXPRESSION {IC} ")"
    doc: >
        an expression in parenthesis
    example: |
        let result = (1 + 5) * 3;

PARENTHETICAL_INVOCATION:
    syntax: >
        EXPRESSION {IC} "(" [{IC} (ARGUMENT|ARGUMENT_PACK)] {{IC} "," [{IC} (ARGUMENT|ARGUMENT_PACK)]} {IC} ")"

PAYLOAD:
    syntax: >
        {all}
    doc: >
        used in EMBEDDED_COMMENT, EMBEDDED_STRING

PLATFORM:
    syntax: >
        "_" {letter | number | PLATFORM}
    filter: longest
    see:
        - FUNCTION

POST_DEC:
    syntax: >
        EXPRESSION {IC} "--"
    precedes: [NEGATION, BINARY_OP]

POST_INC:
    syntax: >
        EXPRESSION {IC} "++"
    precedes: [NEGATION, BINARY_OP]

PRE_DEC:
    syntax: >
        "--" {IC} EXPRESSION
    precedes: [NEGATION, BINARY_OP]

PRE_INC:
    syntax: >
        "++" {IC} EXPRESSION
    precedes: [NEGATION, BINARY_OP]

PREPEND:
    syntax: >
        EXPRESSION {IC} "&" {IC} EXPRESSION
    assoc: right
    doc: >
        create a new Collection starting with the left hand side followed by the elements of the right hand side Collection
    example: >
        x := 1 & [2, 3, 4, 5];
        y := [1, 2, 3, 4, 5];
        x = y;

RADICAL:
    syntax: >
        "√" {IC} EXPRESSION
    precedes: [DIVISION, INTEGER_DIVISION, MODULATION, MULTIPLICATIVE_OP, SUBTRACTION, ADDITION, ADD_SUB]

RANGE:
    syntax: >
        "(" {IC} "..." {IC} EXPRESSION {IC} ( "]" | ")" ) | ( "[" | "(" ) {IC} EXPRESSION {IC} "..." {IC} ")" | ( "(" | "[" ) {IC} EXPRESSION {IC} "..." {IC} EXPRESSION {IC} ( "]" | ")" )
    doc: >
        create a totally-ordered open/closed/half-open discreet/continuous Collection
    examples:
        - |
            wholeNumbers := [ 0 ... ); // the non negative integers - the set is infinite and denumerable
        - |
            positivesIntsToN := [ 1 ... n ]; // the integers 1 to n inclusive - the set is finite and denumerable
        - |
            negativeReals := ( ... 0.0 ) // the negative real numbers - the set is infinite and nondenumerable

READ_LOCK:
    syntax: >
        "read_lock" {IC} PARENTHETICAL {IC} BLOCK

RECORD:
    syntax: >
        "record" {ICR} TYPE

REGEX:
    syntax: >
        "R" STRING

RELATIONAL_COLLECTION_OP:
    syntax: >
        HAS | IN | NOT_HAS | NOT_IN
    doc: >
        relational operators on collections

RELATIONAL_OP:
    syntax: >
        CASTS | DOWNCASTS | EXACTLY | IMPLEMENTS | INEQUALITY | INHERITS | IS | RELATIONAL_COLLECTION_OP | UPCASTS
    precedes: [BINARY_LOGICAL_OP]

RETURN:
    syntax: >
        "return" [{IC} "[" {IC} EXPRESSION {IC} "]"] [ {IC} EXPRESSION ]
    doc: >
        exit the current function, optionally returning a value
    notes: >
        if a square-bracketed value is appended to a the "return" keyword, that many scope levels plus one will return. "return" is the same as "return[0]".

SET:
    syntax: >
        "{|" {IC} [EXPRESSION {{IC} "," {IC} EXPRESSION} {IC}] "|}"
    precedes: [MAGNITUDE]

SET_COMPREHENSION:
    syntax: >
        "{" {IC} EXPRESSION {IC} "|" {IC} EXPRESSION {IC} "}"
    doc: >
        create a Collection, substituting variables bound in the right hand side into the left hand side
    example: |
        { x | x ∈ ℝ ∧ x < 3 }

SHIFTL:
    syntax: >
        EXPRESSION {IC} "<<" {IC} EXPRESSION
    assoc: left
    doc: >
        shift left

SHIFTR:
    syntax: >
        EXPRESSION {IC} ">>" {IC} EXPRESSION
    assoc: left
    doc: >
        shift right

SLICE:
    syntax: >
        EXPRESSION {IC} ":" {IC} EXPRESSION
    doc: >
        used in ARRAY_INVOCATION

STATEMENT:
    syntax: >
        ( ASSIGNMENT_CHAIN | BREAK | CONTINUE | DEFINITION | DO | EXPRESSION | FOR | FOR_COLLECTION | FREE | IMPORT | LOCK | LOOP | READ_LOCK | RETURN | THROW | TRY | TYPE_CONSTRAINT | WRITE_LOCK | USING ) {IC} ";"
    doc: >
        top-level statement syntax

STATEMENT_SCOPE:
    syntax: >
        {IC | STATEMENT}
    doc: >
        zero or more statements, the top level syntax rule for source files

STRING:
    syntax: >
        c_string
    
SUBSET_CHAIN:
    syntax: >
        EXPRESSION {IC} SUBSET_CHAIN_LOOP
    doc: >
        One or more subset, proper subset, or equality relations
    examples:
        - |
            S ⊂ T;
        - |
            S ⊆ T ⊂ U = V;

SUBSET_CHAIN_LOOP:
    syntax: >
        ("="|"⊆"|"subs"|"⊂"|"psubs") {IC} EXPRESSION [{IC} SUBSET_CHAIN_LOOP]
    precedes: [EXPRESSION]
    see:
        - SUBSET_CHAIN

SUBTRACTION:
    syntax: >
        EXPRESSION {IC} "-" {IC} EXPRESSION
    assoc: left

SUPERSET_CHAIN:
    syntax: >
        EXPRESSION {IC} SUPERSET_CHAIN_LOOP
    doc: >
        One or more superset, proper superset, or equality relations
    examples:
        - |
            S ⊃ T;
        - |
            S ⊇ T ⊃ U = V;

SUPERSET_CHAIN_LOOP:
    syntax: >
        ("="|"⊇"|"sups"|"⊃"|"psups") {IC} EXPRESSION [{IC} SUPERSET_CHAIN_LOOP]
    precedes: [EXPRESSION]
    see:
        - SUPERSET_CHAIN

SWIZZLE:
    syntax: >
        EXPRESSION {IC} ("⋮" | "_swiz_") {IC} EXPRESSION

SYMMETRIC_DIFFERENCE:
    syntax: >
        EXPRESSION {IC} "⊖" {IC} EXPRESSION
    assoc: left
    doc: >
        the set-theoretic symmetric disjunction (Collection xor)

THIS:
    syntax: >
        "this" [{IC} "[" {IC} EXPRESSION {IC} "]"]
      
THIS_FUNC:
    syntax: >
        "this_func" [{IC} "[" {IC} EXPRESSION {IC} "]"]
    
THIS_TYPE:
    syntax: >
        "this_type" [{IC} "[" {IC} EXPRESSION {IC} "]"]
    
THROW:
    syntax: >
        "throw" [{IC} "[" {IC} EXPRESSION {IC} "]" ] [{IC} EXPRESSION]
    doc: >
        raise an exception with an optional value which must implement Exception if specified
    notes: >
        if throw is followed by a square-bracketed expression, that many stack frames will unwind before throwing the exception. "throw" is the same as "throw[0]".
        
    see:
        - TRY

TIME:
    syntax: >
        ["-"] decimal_digit decimal_digit ":" decimal_digit decimal_digit ":" decimal_digit decimal_digit ["." decimal_digit {decimal_digit}] ["Z" | (("+"|"-") decimal_digit decimal_digit [":" decimal_digit decimal_digit])]

TRY:
    syntax: >
        "try" {IC} EXPRESSION {IC} "catch" {IC} EXPRESSION {"catch" {IC} EXPRESSION} [{IC} "finally" {IC} EXPRESSION]
    doc: >
        executes the specified nullary void function of the first expression, catching exceptions that pattern match the function(s) of the second expression, and then executes the third expression unconditionally

TUPLE:
    syntax: >
        "(|" {IC} EXPRESSION {{IC} "," {IC} EXPRESSION} {IC} "|)"
    precedes: [MAGNITUDE]
    doc: >
        create a finite, ordered list of elements

TYPE:
    syntax: >
        "type" {IC} ["inheriting" {IC} INHERITANCE_LIST {IC}] ["implementing" {IC} INHERITANCE_LIST {IC}] "{" TYPE_SCOPE "}"
    doc: >
        create a type
    example: |
        bank_account := type inheriting account {
            <float> balance @ 0;
        };

TYPE_CONSTRAINT:
    syntax: >
        TYPE_CONSTRAINT_HEAD {IC} TYPE_CONSTRAINT_CHAIN

TYPE_CONSTRAINT_CHAIN:
    syntax: >
        (DECLARATION|ASSIGNMENT_CHAIN|DEFINITION) [{IC} "," {IC} TYPE_CONSTRAINT_CHAIN]

TYPE_CONSTRAINT_HEAD:
    syntax: >
        [XML_DOC_STRING {IC}] [(VISIBILITY_MODIFIER) {IC}] ["static" {IC}] ["extern" {IC}] (TYPE_DEREFERENCE | VOLATILE_TYPE_DEREFERENCE | IMPLICIT_TYPE_DEREFERENCE | VOLATILE_IMPLICIT_TYPE_DEREFERENCE)

TYPE_DEREFERENCE:
    syntax: >
        "<" {IC} EXPRESSION {IC} ">"
    doc: >
        use a variable/constant as a typename

TYPE_INVOCATION:
    syntax: >
        EXPRESSION ( "<" [{IC} (ARGUMENT|ARGUMENT_PACK)] {{IC} "," [{IC} (ARGUMENT|ARGUMENT_PACK)]} {IC} ">" )

TYPE_SCOPE:
    syntax: >
        {IC} {TYPE_STATEMENT {IC}}
    doc: >
        zero or more statements or member declarations/definitions, used strictly in the TYPE syntax only
    notes: >
        Any use of the assignment operator indicates an instance member declaration. Any use of the definition operator indicates a static member of the class, since it is immutable it will not vary between instances. Like in statement_scope, an execution context is available and will execute any top-level statements inside the type.

TYPE_SCOPE_ASSIGNMENT_CHAIN:
    syntax: >
        [XML_DOC_STRING {IC}] IDENTIFIER [{IC} MEMBER_OFFSET] {IC} ("←"|"<-") {IC} (EXPRESSION|ASSIGNMENT_CHAIN)
    precedes: [EXPRESSION]

TYPE_SCOPE_DECLARATION:
    syntax: >
        [XML_DOC_STRING {IC}] IDENTIFIER [{IC} MEMBER_OFFSET]

TYPE_SCOPE_TYPE_CONSTRAINT:
    syntax: >
        TYPE_CONSTRAINT_HEAD {IC} TYPE_SCOPE_TYPE_CONSTRAINT_CHAIN
    precedes: [TYPE_CONSTRAINT]

TYPE_SCOPE_TYPE_CONSTRAINT_CHAIN:
    syntax: >
        [XML_DOC_STRING {IC}] (TYPE_SCOPE_DECLARATION|TYPE_SCOPE_ASSIGNMENT_CHAIN|DEFINITION) [{IC} "," {IC} TYPE_SCOPE_TYPE_CONSTRAINT_CHAIN]

TYPE_STATEMENT:
    syntax: >
        (VISIBILITY_MODIFIER {IC} ":") | TYPE_SCOPE_TYPE_CONSTRAINT | STATEMENT
    doc: >
        top-level type syntax

UNARY_ARITHMETIC_OP:
    syntax: >
        FACTORIAL | NEGATION | POST_DEC | POST_INC | PRE_DEC | PRE_INC | RADICAL

UNARY_LOGICAL_OP:
    syntax: >
        ALL | EXISTS | EXISTS_ONE | NOT
    precedes: [BINARY_LOGICAL_OP]

UNARY_OP:
    syntax: >
        CARDINALITY | KLEENE_STAR | UNARY_ARITHMETIC_OP | UNARY_LOGICAL_OP

UNION:
    syntax: >
        EXPRESSION {IC} "∪" {IC} EXPRESSION
    assoc: either
    doc: >
        the set-theoretic union

UNIT_DIVISION:
    syntax: >
        DIMENSION "/" DIMENSION
    assoc: left
    doc: >
        dimensional analysis "per"
    see:
        - DIMENSIONAL_NUMBER

UNIT_EXPONENTIATION:
    syntax: >
        DIMENSION "^" NON_FRACTIONAL
    assoc: right
    precedes: [UNIT_MULTIPLICATION, UNIT_DIVISION]
    doc: >
        dimensional analysis square units, cubed units, etc
    see:
        - DIMENSIONAL_NUMBER

UNIT_MULTIPLICATION:
    syntax: >
        DIMENSION "*" DIMENSION
    assoc: left
    doc: >
        dimensional analysis "by"
    see:
        - DIMENSIONAL_NUMBER

UPCASTS:
    syntax: >
        EXPRESSION {IC} "upcasts" {IC} EXPRESSION
        
USING:
    syntax: >
        "using" {IC} "(" {IC} EXPRESSION {IC} ")" {IC} BLOCK
    doc: >
        values in the specified value are visible, and any value constructed inside the expression that is not visible from outside scopes, is destructed when the scope exits
        
VECTOR_NORM:
    syntax: >
        "||" {IC} EXPRESSION {IC} "||"
    doc: >
        create a Vector<D, N> normalized to unit length

VISIBILITY_MODIFIER:
    syntax: >
        ("public"|"protected"|"protected internal"|"internal"|"private")

VOLATILE_IMPLICIT_TYPE_DEREFERENCE:
    syntax: >
        "<" {IC} "volatile" {IC} ">"

VOLATILE_TYPE_DEREFERENCE:
    syntax: >
        "<" {IC} "volatile" {IC} EXPRESSION {IC} ">"

WHOLE_NUMBER:
    syntax: >
        ("1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9") {"0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"}
    see:
        - TYPE_SCOPE

WRITE_LOCK:
    syntax: >
        "write_lock" PARENTHETICAL BLOCK

WS:
    syntax: >
        white_space {white_space}
    filter: longest
    doc: >
        consumes whitespaces between other tokens

XML_DOC_STRING:
    syntax: >
        "```" XML_DOC_STRING_INTERIOR "```"
    doc: >
        documentation string bounded by arbirtrarily-sized delimiters

XML_DOC_STRING_INTERIOR:
    syntax: >
        PAYLOAD | ("`" XML_DOC_STRING_INTERIOR "`")
XOR:
    syntax: >
        EXPRESSION {IC} ("⊕" |"xor") {IC} EXPRESSION
    assoc: left
