---
#References
#http://math.stackexchange.com/questions/1150746/what-is-the-operator-precedence-for-quantifiers
#http://math.stackexchange.com/questions/266182/order-of-precedence-of-set-operators
#http://math.stackexchange.com/questions/128504/boolean-algebra-operation-precedence
#http://math.stackexchange.com/questions/340425/operator-precedence-for-integer-division

ADD_SUB:
    syntax: >
        EXPRESSION {IC} ("±"|"+-") {IC} EXPRESSION
    assoc: left
    doc: >
        the analytic value storing the simultaneous results of addition and subtraction

ADD_SUB_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} ("±"|"+-") ("<-"|"←") {IC} EXPRESSION
    doc: Assign the analytic value storing the simultaneous results of addition and subtraction of the two operands and assign the result to the first.
    see:
        - ADD_SUB

ADDITION:
    syntax: >
        EXPRESSION {IC} "+" {IC} EXPRESSION
    assoc: either

ADDITION_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} ("+<-"|"+←"|"⥆") {IC} EXPRESSION
    doc: Add the two operands and assign the result to the first.
    see:
        - ADDITION

ALL:
    syntax: >
        ("∀"|"all") {IC} EXPRESSION
    doc: >
        constrain ALL elements of a Collection to be true
    example: |
        someNumbers := {| -100, 1, 100 |};

        if (∀ { x >= 0 | x ∈ someNumbers}) {
            print("None of the numbers are negative");
        } else {
            print("Some of the numbers are negative");
        }
    notes: >
        The values in the collection need not be Bool, so long as Bool casts T is true, where T is the type of each element.
    see:
        - EXISTS
        - EXISTS_ONE

ALLOCATION:
    syntax: >
        "alloc" {IC} PARENTHETICAL_INVOCATION
    doc: >
        create an object on the heap

AND:
    syntax: >
        EXPRESSION {IC} ("∧"|"and") {IC} EXPRESSION
    assoc: either
    precedes: [OR, IMPLICATION, XOR, IFF]

AND_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} ("∧"|"and") ("<-"|"←") {IC} EXPRESSION
    doc: And the two operands and assign the result to the first.
    see:
        - AND

ARGUMENT:
    syntax: >
        EXPRESSION

ARGUMENT_PACK:
    syntax: >
        EXPRESSION {IC} "..."

ARRAY:
    syntax: >
        "[" {IC} [$EXPRESSION {{IC} "," {IC} $EXPRESSION} {IC} ] "]"

ARRAY_INDEXER:
    syntax: >
        {IC} (ARGUMENT|ARGUMENT_PACK|SLICE)

ARRAY_INVOCATION:
    syntax: >
        %target(EXPRESSION) "[" %argsHead[$ARRAY_INDEXER] %argsTail{{IC} "," [$ARRAY_INDEXER]} {IC} "]"

ASM_EXPRESSION:
    syntax: >
        ASM_IDENTIFIER | ASM_PTR_ARITHMETIC_ATT | ASM_PTR_ARITHMETIC_INTEL | NON_FRACTIONAL

ASM_IDENTIFIER:
    syntax: >
        ["%"] IDENTIFIER

ASM_FUNCTION:
    syntax: >
        [ "(" {IC} [ $PARAMETER {{IC} "," {IC} $PARAMETER} {IC} ] ")" {IC} ] [FUNCTION_MODIFIER_0] "asm" {IC} "{" ASM_SCOPE "}"

ASM_OP:
    syntax: >
        (lowercase_letter) {lowercase_letter}

ASM_PTR_ARITHMETIC_ATT:
    syntax: >
        (ASM_IDENTIFIER ":" NON_FRACTIONAL) | (ASM_IDENTIFIER ":" NON_FRACTIONAL ASM_PTR_ARITHMETIC_ATT_REG) | (NON_FRACTIONAL ASM_PTR_ARITHMETIC_ATT_REG)

ASM_PTR_ARITHMETIC_ATT_REG:
    syntax: >
        "(" [$ASM_IDENTIFIER] ["," $ASM_IDENTIFIER ["," NON_NEG_NON_FRACTIONAL]] ")"

ASM_PTR_ARITHMETIC_INTEL:
    syntax: >
        [("BYTE"|"WORD"|"DWORD"|"QWORD") " PTR"] "[" [ASM_IDENTIFIER ":"] ASM_IDENTIFIER ["+" ASM_IDENTIFIER ["*" NON_NEG_NON_FRACTIONAL]] [("+"|"-") NON_NEG_INTEGER] "]"

ASM_SCOPE:
    syntax: >
        {IC | ASM_STATEMENT}

ASM_STATEMENT:
    syntax: >
        ASM_OP [{IC} ASM_EXPRESSION {{IC} "," [{IC} ASM_EXPRESSION]}] {IC} "\n"

ASSIGNMENT_CHAIN:
    syntax: >
        [$XML_DOC_STRING {IC}] $IDENTIFIER {IC} ("←"|"<-") {IC} ($EXPRESSION|ASSIGNMENT_CHAIN)
    precedes: [EXPRESSION, LESSER_CHAIN]
    doc: >
        place the given value(s) into the given variable(s)
    example: |
        iPow2 ← -1;
    notes: |
        <p>The left hand side may be a non lvalue (in C parlance). Rather, some algebras and solvers solve free variables.</p>
        <div class="code">
            <p>Example</p>
            <pre>x + 1 ← 0;</pre>
        </div>
        <p>Assignment operations can be chained together</p>
        <div class="code">
            <p>Example</p>
            <pre>a ← b ← c;</pre>
        </div>

ATTRIBUTE:
    syntax: >
        "@" {IC} EXPRESSION {IC} "@"

BIJECTION:
    syntax: >
        EXPRESSION {IC} ("↔"|"<->") {IC} EXPRESSION
    assoc: either
    doc: >
        a bijection exists between the left and right hand operands

BINARY_ARITHMETIC_OP:
    syntax: >
        ADD_SUB | ADDITION | DIVISION | EXPONENTIATION | INTEGER_DIVISION | MODULATION | MULTIPLICATIVE_OP | SHIFTL | SHIFTR | SUBTRACTION
    doc: >
        the collection of binary operators that work on numbers (among other things)

BINARY_COLLECTION_OP:
    syntax: >
        BIJECTION | INTERSECTION | SYMMETRIC_DIFFERENCE | UNION
    doc: >
        binary operators on collections

BINARY_LOGICAL_OP:
    syntax: >
        AND | IFF | IMPLICATION | MAPS_TO | NAND | NOR | OR | XOR

BINARY_OP:
    syntax: >
        BINARY_ARITHMETIC_OP | BINARY_COLLECTION_OP | BINARY_LOGICAL_OP | BITWISE_OP | CONSTRUCTIVE_OP | RELATIONAL_OP
    doc: >
        a sequence of one or more punctuation (and special) characters representing an infix operator
    notes: >
        <h4>* (<a href="/documentation/syntax/MULTIPLICATION.php">multiplication</a>)</h4>
        <ul>
            <li>as the arithmetic operator, multiplication: Number * Number → Number</li>
            <li>as the product of Types, making a tuple Type: Type * Type → Type</li>
            <li>as the the inner product of two vectors as an alternative to <a href="/documentation/syntax/DOT_PRODUCT.php">dot_product</a>: Vector&lt;d, Number&gt; * Vector&lt;d, Number&gt; → Number</li>
            <li>See also: <a href="/documentation/syntax/KLEENE_STAR.php">kleene_star</a></li>
        </ul>

        <h4>× (<a href="/documentation/syntax/CROSS_PRODUCT.php">cross_product</a>)</h4>
        <p>The unicode character MULTIPLICATION SIGN (U+00D7) (not to be confused with x, the unicode character LATIN SMALL LETTER X (U+0078))
        may be typed as <code>_x_</code>.</p>
        <ul>
            <li>as the arithmetic operator "multiplication"</a>
                Function signature: Number * Number → Number
            </li>
            <li>as the cross product of two three component vectors <a href="/documentation/syntax/CROSS_PRODUCT.php">cross_product</a>
                Function signature: Vector&lt;3&gt; * Vector&lt;3&gt; → Vector&lt;3&gt;
            </li>
            <li>as the product of Types, making a tuple Type
                Function signature: Type * Type → Type
            </li>
        </ul>

        <h4>→ (arrow)</h4>
        <p>The unicode character RIGHTWARD ARROW (U+2192) may be typed as <code>-&gt;</code>.
        The arrow operator creates an object which is simultaneously a <b>function type</b>
        and a <a href="/documentation/syntax/MAPS_TO.php">maps_to</a> relation. The signature of a function is composed with the left hand side defining the function's domain (the input parameter types) and the right hand defining the codomain (the return type).</p>
        <ul>
            <li>as a factory of a function type
                Function signature: Type * Type → Type
            </li>
            <li>as a relation indicating a <a href="/documentation/syntax/MAPS_TO.php">maps_to</a> constraint
                Function signature: Set * Set → Relation
            </li>
        </ul>

        <h4>∘ (ring)</h4>
        <p>The unicode character RING OPERATOR (U+2218) may be typed as <code>_o_</code>.
            The ring operator composes functions such that <code>(f ○ g)(x)</code> is equivalent to
            <code>f(g(x))</code>.</p>
        <ul>
            <li>as the <a href="/documentation/syntax/COMPOSITION.php">composition</a> operator
                Function signature: (X → Y) * (Y → Z) → (X → Z)
            </li>
        </ul>

        <h4>& (prepend)</h4>
        <p>The prepend operator creates a new collection, putting the left hand operand at the beginning and then appending the collection in the right hand operand</p>
        <ul>
            <li>as the denumerable constructor <a href="/documentation/syntax/PREPEND.php">prepend</a>
                Function signature: T * Collection&lt;T&gt; -&gt; Collection&lt;T&gt;
            </li>
        </ul>

        <h4>∪ (set_union)</h4>
        <p>The unicode character UNION (0x222A) may be typed as <code>_u_</code>. Not to be confused with 'U' (0x55).</p>
        <ul>
            <li>as the set union
                Function signature: Set * Set → Set
            </li>
        </ul>

        <h4>∩ (set_intersection)</h4>
        <p>The unicode character INTERSECTION (0x2229) may be typed as <code>_i_</code>.
        <ul>
            <li>as the set_intersection operator
                Function signature: Set * Set → Set
            </li>
        </ul>

        <h4>/ (slash)</h4>
        <ul>
            <li>as the collection_difference operator
                Function signature: Collection * Collection → Collection
            </li>
            <li>as the division operator
                Function signature: Number * Number → Number
            </li>
        </ul>

        <h4>⊕ (xor)</h4>
        <p>The unicode character CIRCLED PLUS (0x2295) may be typed as <code>_xor_</code>.</p>
        <ul>
            <li>as the set_symmetric_difference operator
                Function signature: Set * Set → Set
            </li>
            <li>as the xor operator
                Function signature: Bool * Bool → Bool
                Function signature: Integer * Integer → Integer
            </li>
        </ul>

BIT_AND:
    syntax: >
        EXPRESSION {IC} "&&" {IC} EXPRESSION
    assoc: either

BIT_AND_ASSIGNMENT:
    syntax:
        EXPRESSION {IC} "&&" ("<-"|"←") {IC} EXPRESSION
    doc: Bitwise and the two operands and assign the result to the first.
    see:
        - BIT_AND

BIT_NOT:
    syntax: >
        "~~" {IC} EXPRESSION

BIT_NOT_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} "~~" ("<-"|"←")
    doc: Bitwise not the operand and assign the result to it.
    see:
        - BIT_NOT

BIT_OR:
    syntax: >
        EXPRESSION {IC} "||" {IC} EXPRESSION
    assoc: either

BIT_OR_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} "||" ("<-"|"←") {IC} EXPRESSION
    doc: Bitwise or the two operands and assign the result to the first.
    see:
        - BIT_OR

BIT_XOR:
    syntax: >
        EXPRESSION {IC} "^^" {IC} EXPRESSION
    assoc: either

BIT_XOR_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} "^^" ("<-"|"←") {IC} EXPRESSION
    doc: Bitwise xor the two operands and assign the result to the first.
    see:
        - BIT_XOR

BITWISE_OP:
    syntax: >
        BIT_AND | BIT_OR | BIT_XOR

BLOCK:
    syntax: >
        "{" STATEMENT_SCOPE "}"

BOOL:
    syntax: >
        "true" | "false"
    doc: >
        the two ordinals of the Bool type
    notes: >
        These are included as syntax elements as they are literals, not constants.

BREAK:
    syntax: >
        "break" [({IC} "[" {IC} $EXPRESSION {IC} "]") | (IC {IC} $IDENTIFIER)]
    doc: >
        terminate the containing for, do, or while/until loop
    notes: >
        If a square-bracketed value is appended to a the "break" keyword, that many scope levels plus one will terminate. "break" is the same as "break[0]". If a variable identifier follows the "break" keyword, the iterative flow-control primitive associated with that variable will be affected.
    example: >
        for (i in X) {
            for (j in Y) {
                break i;
            }
        }

CARDINALITY:
    syntax: >
        "#" {IC} EXPRESSION
    precedes: [BINARY_OP]

CAST:
    syntax: >
        PARENTHETICAL {IC} EXPRESSION
    precedes: [BINARY_OP]
    doc: >
        change the type of the specified expression to the parenthesized type

CASTS:
    syntax: >
        EXPRESSION {IC} "casts" {IC} EXPRESSION

CEILING:
    syntax: >
        ("⌈" {IC} EXPRESSION {IC} "⌉") | ( "|'" {IC} EXPRESSION {IC} "'|" )

COMPOUND:
    syntax: >
        EXPRESSION {IC} "|" {IC} EXPRESSION
    assoc: left

COMPOUND_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} "|" ("<-"|"←") {IC} EXPRESSION
    doc: Compound the two operands and assign the result to the first.
    see:
        - COMPOUND

COMMENT:
    syntax: >
        "/*" {all} "*/"
    doc: >
        an inline comment

COMPLEMENT:
    syntax: >
        EXPRESSION {IC} "ᶜ"
    precedes: [BINARY_OP]
    doc: >
        the universal set excluding the elements of the collection

COMPOSITION:
    syntax: >
        EXPRESSION {IC} ("∘"|"_o_") {IC} EXPRESSION
    assoc: either
    doc: >
        function composition operator

COMPOSITION_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} ("∘"|"_o_") ("<-"|"←") {IC} EXPRESSION
    doc: Compose the two operands and assign the result to the first.
    see:
        - COMPOSITION

CONDITIONAL:
    syntax: >
        %condition(EXPRESSION) {IC} "?" {IC} %true_case(EXPRESSION) {IC} ":" {IC} %false_case(EXPRESSION)
    assoc: right
    doc: >
        ternary conditional
    notes: >
        If the first expression is true then evaluates to the second expression otherwise evaluates to the third expression.

CONSTRUCTIVE_OP:
    syntax: >
        COMPOSITION | COMPOUND | PREPEND | NULL_COALESCE
    doc: >
        operators that are constructive for making values

CONTINUE:
    syntax: >
        "continue" [({IC} "[" {IC} $EXPRESSION {IC} "]") | (IC {IC} $IDENTIFIER)]
    doc: >
        begin the next iteration in the containing for, do, or while/until loop
    notes: >
        If a square-bracketed value is appended to the "continue" keyword, that many scope levels plus one will continue. "continue" is the same as "continue[0]". If a variable identifier follows to the continue keyword, the iterative flow-control primitive associated with that variable is affected.
    example: >
        for (i in X) {
            for (j in Y) {
                continue i;
            }
        }

CROSS_PRODUCT:
    syntax: >
        EXPRESSION {IC} ("×"|"_x_") {IC} EXPRESSION
    assoc: left
    precedes: [DOT_PRODUCT]
    doc: >
        scalar multiplication or Vector<3, N> cross product

CROSS_PRODUCT_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} ("×"|"_x_") ("<-"|"←") {IC} EXPRESSION
    doc: Cross multiply the two operands and assign the result to the first.
    see:
        - CROSS_PRODUCT

DATE:
    syntax: >
        DATE_YEAR_MONTH_DAY | DATE_YEAR_DAY

DATE_YEAR_MONTH_DAY:
    syntax: >
        decimal_digit decimal_digit decimal_digit decimal_digit "-" decimal_digit decimal_digit "-" decimal_digit decimal_digit
    precedes: [SUBTRACTION]
    doc: >
        a date literal

DATE_YEAR_DAY:
    syntax: >
        decimal_digit decimal_digit decimal_digit decimal_digit "-" decimal_digit decimal_digit decimal_digit
    precedes: [SUBTRACTION]

DATE_TIME:
    syntax: >
        DATE "T" TIME

DECLARATION:
    syntax: >
        [$XML_DOC_STRING {IC}] $IDENTIFIER
    doc: >
        declare a variable and optionally assign a value to it
    examples:
        - |
            <Number> x <- 100;
        - |
            <> name <- "Alice"; //implicitly type String
        - |
            object <- {
                "employees":[
                    (|"John", "Doe"|),
                    (|"Anna", "Smith"|),
                    (|"Peter", Jones"|)],
                "contractors":[
                    (|"Matt", "Williams"|)]
            };

            object <- (x) { return x*2; }; //no type constraint
    see:
        - STATEMENT

DEFINITION:
    syntax: >
        [$XML_DOC_STRING {IC}] $IDENTIFIER {IC} ":=" {IC} $EXPRESSION
    doc: >
        define a constant, an alias for the valuation of a specified expression
    example: >
        <Double> almostPi := 355/113;

DELTA:
    syntax: >
        ("Δ"|"_delta_") ["^" $WHOLE_NUMBER] $EXPRESSION
    precedes: [EXPONENTIATION, BINARY_OP]

DIMENSION:
    syntax: >
        IDENTIFIER | DIMENSIONAL_ANALYSIS_OP
    doc: >
        a dimension used in dimensional analysis

DIMENSIONAL_ANALYSIS_OP:
    syntax: >
        UNIT_DIVISION | UNIT_EXPONENTIATION | UNIT_MULTIPLICATION
    doc: >
        operators in a dimension

DIMENSIONAL_NUMBER:
    syntax: >
        NON_NEG_NUMBER DIMENSION
    precedes: [EXPONENTIATION, BINARY_OP]
    doc: >
        a number with a trailing dimension

DIVISION:
    syntax: >
        EXPRESSION {IC} ("÷"|"/" ) {IC} EXPRESSION
    assoc: left
    precedes: [INTEGER_DIVISION, MAPS_TO, MODULATION, SUBTRACTION, ADDITION, ADD_SUB]
    doc: >
        division or splits the left hand side collection into a collection of collections each the size of the right hand side

DIVISION_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} ("÷"|"/" ) ("<-"|"←") {IC} EXPRESSION
    doc: Add the two operands and assign the result to the first.
    see:
        - 

DO:
    syntax: >
        "do" {IC} $EXPRESSION [ {IC} ("while"|"until") {IC} %condition(PARENTHETICAL) ]
    doc: >
        invoke a specified nullary void function (expression) once and then repeatedly while or until the parenthetical evaluates to true (when coerced to bool), unless the optional portion is omitted, in which case the function is invoked indefinitely
    see:
        - LOOP

DOT_PRODUCT:
    syntax: >
        EXPRESSION {IC} ("⋅"|"_dot_") {IC} EXPRESSION
    assoc: left
    doc: >
        scalar multiplication or Vector<D, N> inner product
        
DOWNCASTS:
    syntax: >
        EXPRESSION {IC} "downcasts" {IC} EXPRESSION

EMBEDDED_COMMENT:
    syntax: >
        "/***" EMBEDDED_COMMENT_INTERIOR "***/"
    filter: shortest
    precedes: [COMMENT]
    doc: >
        a comment bounded by arbirtrarily-sized delimiters
    example: |
        /**** this is an embedded_comment
        ***/ the characters at the start of this line have no affect on this ongoing comment
        Embed blocks of code that themselves contain block comments:
            /* Do the thing */
            thing();
        No problem. Now, lets end this comment. ****/
    notes: >
        This allows for commented code to be safely commented out completely by including a sufficient number of asterisks to serve as an opening and closing delimiter.

EMBEDDED_COMMENT_INTERIOR:
    syntax: >
        $PAYLOAD | "*" EMBEDDED_COMMENT_INTERIOR "*"
    precedes: [PAYLOAD]

EMBEDDED_NEWLINE_STRING:
    syntax: >
        "\"\"\"" EMBEDDED_NEWLINE_STRING_INTERIOR "\"\"\""
    filter: shortest
    precedes: [EMBEDDED_STRING]

EMBEDDED_NEWLINE_STRING_INTERIOR:
    syntax: >
        ("\n" $PAYLOAD "\n") | ("\"" EMBEDDED_NEWLINE_STRING_INTERIOR "\"")
    precedes: [PAYLOAD]

EMBEDDED_STRING:
    syntax: >
         "\"\"\"" EMBEDDED_STRING_INTERIOR "\"\"\""
    filter: shortest
    doc: >
        a string bounded by arbirtrarily-sized delimiters
    example: |
        stringWithDoubleQuotes := """""
        The remainder of this is a string literal, excluding the five quotes at the very end.
        We can use four double quotes, like """", but not 5 which is the number of quotes that
        start this string literal. If a string literal with 100 consecutive double quotes in it
        were desired, we would then use 101 double quotes to start and end the string literal.
        """""
    notes: |
        <p>An embedded_string is similar to a regular string literal of the form:</p>
        <div class="code">
            <p>Typical string literal</p>
            <pre>"hello world"</pre>
        </div>
        <p>except that it permits the text to contain any finite number of double quotes. An embedded_string begins with three or more double quotes followed by a new line character, and ends with a new line character followed by the same number of double quotes. All white spaces, characters, and other bytes between the opening and closing delimiter becomes a string literal.</p>

EMBEDDED_STRING_INTERIOR:
    syntax: >
        $PAYLOAD | ("\"" EMBEDDED_STRING_INTERIOR "\"")
    precedes: [PAYLOAD]

END_OF_LINE_COMMENT:
    syntax: >
        "//" {not_newline} "\n"

ENUM:
    syntax: >
        "enum" {IC} ["inheriting" {IC} INHERITANCE_LIST {IC}] ["implementing" {IC} INHERITANCE_LIST {IC}] "{" [$ENUM_ELEMENT {{IC} ";" {IC} $ENUM_ELEMENT}] "}"
    doc: >
        makes a compound type with static members for each of the elements, and each of those elements inherit/implement those specified inheritance list 
        
ENUM_ELEMENT:
    syntax: >
        $IDENTIFIER [{IC} ":=" {IC} $EXPRESSION]
        
EQUALITY_CHAIN:
    syntax: >
        $EXPRESSION {IC} $EQUALITY_CHAIN_LOOP
    precedes: [GREATER_CHAIN, LESSER_CHAIN, SUBSET_CHAIN, SUPERSET_CHAIN]
    doc: >
        one or more equality relations
    examples:
        - |
            X = Y;
        - |
            X = Y = Z;

EQUALITY_CHAIN_LOOP:
    syntax: >
        "=" {IC} $EXPRESSION [{IC} $EQUALITY_CHAIN_LOOP]
    precedes: [EXPRESSION]
    see:
        - EQUALITY_CHAIN

EXACTLY:
    syntax: >
        EXPRESSION {IC} "exactly" {IC} EXPRESSION
    
EXISTS:
    syntax: >
        ("∃"|"exists") {IC} EXPRESSION
    doc: >
        a constraint asserting that at least one element of the specified Collection is true
    notes: >
        <p>The values in the collection need not be Bool, so long as <code>Bool casts T</code> is true, where T is the type of each element.<p>
    example: |
        shouldRejectLiquorPurchase := (List<Date> patronBirthdates) {
            return ∃{ x > today() - 21yr | x ∈ patronBirthdates };
        }
    see:
        - EXISTS_ONE
        - ALL

EXISTS_ONE:
    syntax: >
        ("∃!"|"exists!") {IC} EXPRESSION
    doc: >
        a constraint asserting that exactly one element of the specified Collection is true
    see:
        - EXISTS
        - ALL

EXPONENTIATION:
    syntax: >
        EXPRESSION {IC} "^" {IC} EXPRESSION
    assoc: right
    precedes: [DIVISION, INTEGER_DIVISION, MODULATION, MULTIPLICATIVE_OP, SUBTRACTION, ADDITION, ADD_SUB]

EXPONENTIATION_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} "^" ("<-"|"←") {IC} EXPRESSION
    doc: Exponentiate the two operands and assign the result to the first.
    see:
        - EXPONENTIATION

EXPRESSION:
    syntax: >
        ARRAY | ASM_FUNCTION | BINARY_OP | BOOL | CAST | CEILING | COMPLEMENT | CONDITIONAL | DATE | DATE_TIME | DELTA | DIMENSIONAL_NUMBER | EMBEDDED_STRING | ENUM | EQUALITY_CHAIN | FLOOR | FUNCTION | GREATER_CHAIN | IDENTIFIER | IF | INVOCATION | LESSER_CHAIN | LIST | MAGNITUDE | MAP | MEMBER_ACCESS | NEAREST_INTEGER | NON_NEG_NUMBER | OBJECT | PARENTHETICAL | RANGE | REGEX | SET | SET_COMPREHENSION | SUBSET_CHAIN | SUPERSET_CHAIN | SWIZZLE | THIS | THIS_FUNC | THIS_TYPE | TIME | TUPLE | TYPE | UNARY_OP | VECTOR_NORM | "context" | "null" | c_string 
    doc: >
        a linearization of an evaluation tree containing constants, variables, operators, invocations, and sub expressions
    notes: >
        null is a literal and so is included in the syntax similarly to true, false and numeric literals (and unlike constants)

EXTERN:
    syntax: >
        "extern"
    precedes: [IDENTIFIER]

FACTORIAL:
    syntax: >
        EXPRESSION {IC} "!"
    precedes: [BINARY_OP]

FACTORIAL_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} "!" ("<-"|"←")
    doc: Factorial the operand and assign the result to it.
    see:
        - FACTORIAL

FLOOR:
    syntax: >
        ( "⌊" {IC} $EXPRESSION {IC} "⌋" ) | ( "|_" {IC} $EXPRESSION {IC} "_|" )

FOR:
    syntax: >
        "for" {IC} "(" {IC} %initializer[ (STATEMENT_SCOPE) {IC} ] %condition(EXPRESSION) {IC} ";" {IC} %step[ ASSIGNMENT_CHAIN {{IC} "," {IC} ASSIGNMENT_CHAIN} {IC} ] ")" {IC} EXPRESSION
    doc: >
        evaluate the last expression repeatedly while the second expression is true, all after evaluating the optional STATEMENT_SCOPE
    examples:
        - |
            for (x ← 0; x < 100; x++) {
                print_line(x);
            };
        -
            annotation: >
                demonstrates the optional statement_scope
            example: |
                spammer := (<UInt> count) {
                    for (count > 0; count--; ) {
                        print("SPAM!!!\n");
                    };
                };
        -
            annotation: >
                more than one statement may be used to initialize, and a blank may be used for the increment expression
            example: |
                mergeSorted := (List<Int> a, List<Int> b) {
                    List<Int> result;
                    <Int>i;
                    <Int>j;
                    for (i ← 0; j ← 0; i < a.count && j < b.count; ) { //blank increment expression
                        if (a[i] < b[j]) {
                            result.add(a[i]);
                            i++;
                        } else {
                            result.add(b[j]);
                            j++;
                        }
                    }
                    for (i < a.count; i++) {
                        result.add(a[i])
                    }
                    for (j < b.count; j++) {
                        result.add(b[j]);
                    }
                    return result;
                }

FOR_COLLECTION:
    syntax: >
        "for" {IC} "(" {IC} (%declaration([ (TYPE_DEREFERENCE | IMPLICIT_TYPE_DEREFERENCE) {IC} ] IDENTIFIER ) | $EXPRESSION ) {IC} ("in"|"∈") {IC} %collection(EXPRESSION) {IC} ")" {IC} %invoke(EXPRESSION)
    doc: >
        evaluate the last expression repeatedly while iterating over the elements of the specified Collection
    examples:
        - |
            <> fibArray = [ 0, 1, 1, 2, 3, 5, 8, 13 ];
            for (element ∈ fibArray) {
                print(element);
            }
        - |
            for ((key, value) ∈ myMap) {
                //do something
            }

FREE:
    syntax: >
        "free" {IC} EXPRESSION

FUNCTION_MODIFIER_0:
    syntax: >
        FUNCTION_MODIFIER_STABILITY|FUNCTION_MODIFIER_1

FUNCTION_MODIFIER_1:
    syntax: >
        FUNCTION_MODIFIER_THROWING|FUNCTION_MODIFIER_2
        
FUNCTION_MODIFIER_2:
    syntax: >
        FUNCTION_MODIFIER_ATOMIC|FUNCTION_MODIFIER_3    
    
FUNCTION_MODIFIER_3:
    syntax: >
        FUNCTION_MODIFIER_PLATFORM|FUNCTION_MODIFIER_4
    
FUNCTION_MODIFIER_4:
    syntax: >
        FUNCTION_MODIFIER_MODEL|FUNCTION_MODIFIER_CALLING_CONVENTION   
    see:
        - FUNCTION

FUNCTION_MODIFIER_ATOMIC:
    syntax: >
        $"atomic" [IC {IC} FUNCTION_MODIFIER_3]

FUNCTION_MODIFIER_CALLING_CONVENTION:
    syntax: >
        "c_call" | "fast_call" | "cold_call" | "ghc_call" | "hipe_call" | "webkit_js_call" | "any_reg_call" | "preserve_most_call" | "preserve_all_call" | "swift_call" | "cxx_fast_tls_call" | "first_target_call" | "x86_std_call" | "X86_fast_call" | "arm_apcs_call" | "arm_aapcs_call" | "arm_aapcs_vfp_call" | "msp430_intr_call" | "x86_this_call" | "ptx_kernel_call" | "ptx_device_call" | "spir_func_call" | "spir_kernel_call" | "intel_ocl_bi_call" | "x86_64_sysv_call" | "x86_64_win64_call" | "x86_vector_call" | "hhvm_call" | "x86_intr_call" | "avr_intr_call" | "avr_signal_call" | "avr_builtin_call"

FUNCTION_MODIFIER_MODEL:
    syntax: >
        %model("pure" | "imperative" | "opaque") [IC {IC} FUNCTION_MODIFIER_CALLING_CONVENTION]

FUNCTION_MODIFIER_PLATFORM:
    syntax: >
        PLATFORM {IC {IC} PLATFORM} [IC {IC} FUNCTION_MODIFIER_4]

FUNCTION_MODIFIER_STABILITY:
    syntax: >
        %stability("stable" | "unstable") [IC {IC} FUNCTION_MODIFIER_1]

FUNCTION_MODIFIER_THROWING:
    syntax: >
        $"throwing" [{IC} ARRAY] [IC {IC} FUNCTION_MODIFIER_2]

FUNCTION:
    syntax: >
        [ "(" {IC} [ $PARAMETER {{IC} "," {IC} $PARAMETER} {IC} ] ")" {IC} ] [FUNCTION_MODIFIER_0 {IC}] $BLOCK
    precedes: [CAST]
    doc: >
        creates a function
    notes: |
        Function objects are invoked using the invocation syntax.
        
        The FUNCTION_MODIFIER_* rules model: ["stable" | "unstable"] ["throwing" | "throwing []" | "throwing [type0, type1]"] ["atomic"] {PLATFORM} ["pure"|"imperative"|"opaque"] with the caveat that there has to be an IC between any modifier and the next (if there is a next)

        The atomic, pure, imperative, and opaque keywords influence assumptions that the compiler may make regarding a functions implementation. The pure keyword indicates that the implementation uses only pull semantics, is idempotent, and has no side effects. Additionally, only constants can be read, which includes value (not by reference/pointer values) passed as formal parameters. Any violation of these constraints causes an error to occur. The imperative keyword indicates that the implementation is likely not tractable, and it may interact with memory or hardware in unknown ways. Without either pure or imperative, the implementation is assumed to be push-pull and tractable. If the tool chain determines that this is not the case, it will fall back to imperative behavior. Pure functions are implicitly atomic.
    examples:
        - |
            (a, b) pure { return a * b; }
        - |
            <int → int> factorial := (x) { return x == 0 ? 1 : x * factorial(x - 1); };
        - |
            <Collection<T> → T> head := (a&b) { return a; }
        - | 

GREATER_CHAIN:
    syntax: >
        $EXPRESSION {IC} $GREATER_CHAIN_LOOP
    doc: >
        one or more greater, greater or equals, or equals relations
    examples:
        - |
            X > Y;
        - |
            X > Y ≥ 0;

GREATER_CHAIN_LOOP:
    syntax: >
        ("="|">"|"=>"|"≥") {IC} $EXPRESSION [{IC} $GREATER_CHAIN_LOOP]
    see:
        - GREATER_CHAIN

HAS:
    syntax: >
        EXPRESSION {IC} ("∋"|"has") {IC} EXPRESSION
    assoc: left
    doc: >
        the in operator, backward

HEX:
    syntax: >
        "0x" hexadecimal_digit {hexadecimal_digit}
    doc: >
        a hexidecimal number

IC:
    syntax: >
        COMMENT | EMBEDDED_COMMENT | END_OF_LINE_COMMENT | WS
    doc: >
        intermediary content - regions that whitespaces and comments can go

IDENTIFIER:
    syntax: >
        %head(letter | "_") %tail{letter | number | "_"}
    filter: longest
    precedes: [ALL]
    doc: >
        text that uniquely identifies a constant or variable within a scope
    notes: |
        <p>The first character must be a letter character. Note that the character groups "letter" and "number" are inclusive of many unicode characters beyond the conventional a-z, A-Z and 0-9. Specifically, all unicode codepoints in a letter or number category may be used in an identifier.</p>
        <p>Examples of valid identifiers:</p>
        <code>
            <ul>
                <li>x</li>
                <li>myVariable</li>
                <li>q4</li>
                <li>Employee</li>
                <li>print_line</li>
                <li>символ</li>
                <li>θ</li>
            </ul>
        </code>

        <p>Non examples:</p>
        <code>
            <ul>
                <li>1stValue</li>
            </ul>
        </code>

IF:
    syntax: >
        "if" {IC} %condition(PARENTHETICAL) {IC} %invoke(EXPRESSION) {{IC} "elif" {IC} %condition(PARENTHETICAL) {IC} %invoke(EXPRESSION)} [ {IC} "else" {IC} %else_invoke(EXPRESSION) ]
    doc: >
        returns the expression corresponding to the first parenthetical that evaluates to true when coerced to a boolean, or the else case if none of them evaluate to true, assuming that the else case is present, otherwise returning void
    example: |
        if (input("What is 1 + 1 ? ") = "2") {
            print("You are correct!");
        } else {
            print("Sorry, you are incorrect.");
        }

IFF:
    syntax: >
        EXPRESSION {IC} ("⇔"|"<=>") {IC} EXPRESSION
    assoc: either
    doc: >
        semantic equivalence

IMPLICATION:
    syntax: >
        EXPRESSION {IC} ("⇒"|"=>") {IC} EXPRESSION
    assoc: right
    precedes: [XOR, IFF]
    doc: >
        implication

IMPLICATION_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} ("⇒"|"=>") ("<-"|"←") {IC} EXPRESSION
    doc: Implicate the two operands and assign the result to the first.
    see:
        - IMPLICATION

IMPLICIT_TYPE_DEREFERENCE:
    syntax: >
        "<" {IC} ">"
    doc: >
        use the type inferred on the right hand side

IMPLEMENTS:
    syntax: >
        EXPRESSION {IC} "implements" {IC} EXPRESSION

IMPORT:
    syntax: >
        "import" {IC} EXPRESSION
    doc: >
        bring the specified 

IN:
    syntax: >
        EXPRESSION {IC} ("∈"|"in") {IC} EXPRESSION
    assoc: left
    doc: >
        Collection membership
    see:
        - FOR_COLLECTION

INEQUALITY:
    syntax: >
        EXPRESSION {IC} ("≠"|"/=") {IC} EXPRESSION
    assoc: left

INHERITS:
    syntax: >
        EXPRESSION {IC} "inherits" {IC} EXPRESSION

INHERITANCE_LIST:
    syntax: >
         [INHERITANCE_ITEM_PREFIX] $EXPRESSION {{IC} "," {IC} [INHERITANCE_ITEM_PREFIX] $EXPRESSION}
    doc: >
        see: type

INHERITANCE_ITEM_PREFIX:
    syntax: >
        (VISIBILITY_MODIFIER | VISIBILITY_MODIFIER IC {IC} $"diamond" | $"diamond") IC {IC}

INTEGER_DIVISION:
    syntax: >
        EXPRESSION {IC} "\\" {IC} EXPRESSION
    assoc: left
    precedes: [SUBTRACTION, ADDITION, ADD_SUB]
    doc: >
        same as ⌊x/y⌋ or collection difference (similar to set difference)

INTEGER_DIVISION_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} "\\" ("<-"|"←") {IC} EXPRESSION
    doc: Integer divide the two operands and assign the result to the first.
    see:
        - INTEGER_DIVISION

INTERSECTION:
    syntax: >
        EXPRESSION {IC} "∩" {IC} EXPRESSION
    assoc: either
    doc: >
        Collection intersection

INTERSECTION_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} "∩" ("<-"|"←") {IC} EXPRESSION
    doc: Set intersect the two operands and assign the result to the first.
    see:
        - INTERSECTION

INVOCATION:
    syntax: >
        PARENTHETICAL_INVOCATION | ARRAY_INVOCATION | TYPE_INVOCATION
    precedes: [RADICAL, NEGATION, BINARY_OP]
    doc: >
        invoke a function, type-function or array-function
    examples:
        - |
            myMethod(1, x^2, "hello\n", someThing)
        - |
            IntList := List<int>; //List is a type function, IntList is a Type
        - |
            print myArray[4]; //4 is ordered and denumerable, myArray implements RandomlyAccessible
    notes: >
        The < > syntactic variety requires the returned value to be a type (it must implement Type), or a function (it must implement Function) that when invoked results in such a type or function. Note that this definition is deliberately recursive. The [ ] syntactic variety requires that each given "indexer" is some element of an ordered set, such as the natural numbers or enum values, and that the invokee is randomly accessible (implements RandomlyAccessible). Lastly, the angle bracket and square bracket syntax are optional; the behavior is identical to being invoked using parentheses. However, alternate syntax is encouraged whenever such requirements are met and helps to both document and enforce the invariants assumed by the author.

IS:
    syntax: >
        EXPRESSION {IC} "is" {IC} EXPRESSION

KLEENE_STAR:
    syntax: >
        EXPRESSION {IC} "*"
    doc: >
        the free monoid operator
    example:
        all_strings := char*;

LESSER_CHAIN:
    syntax: >
        EXPRESSION {IC} LESSER_CHAIN_LOOP
    doc:
        one or more lesser, lesser or equals, or equals relations
    examples:
        - |
            X < Y;
        - |
            X < Y ≤ 0;

LESSER_CHAIN_LOOP:
    syntax: >
        ("="|"<"|"=<"|"≤") {IC} EXPRESSION [{IC} LESSER_CHAIN_LOOP]
    see:
        - LESSER_CHAIN

LIST:
    syntax: >
        "[|" {IC} %elements[EXPRESSION {{IC} ", " {IC} EXPRESSION} {IC} ] "|]"
    doc: >
        a Collection of items
    examples:
        -
            annotation: >
                the empty list
            example: |
                [| |]
        - |
            [|1, 5, 2, 2, 2|]
        - |
            short_days_of_week := ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

LOCK:
    syntax: >
        "lock" {IC} PARENTHETICAL {IC} BLOCK
            
LOOP:
    syntax: >
        ( "while" | "until" ) {IC} PARENTHETICAL {IC} EXPRESSION
    doc: >
        evaluate an expression repeatedly while or until a parenthetical evaluates to true
    see:
        - DO

MAGNITUDE:
    syntax: >
        "|" {IC} EXPRESSION {IC} "|"
    doc: >
        absolute value, vector magnitude, cardinality

MAP:
    syntax: >
        "{" [{IC} EXPRESSION {IC} ":" {IC} EXPRESSION {{IC} "," {IC} EXPRESSION {IC} ":" {IC} EXPRESSION}] {IC} "}"
    precedes: [FUNCTION]
    doc: >
        create an associative Collection implementing Map<a → b>
    example: |
        { "first": "john", "last": "doe" }
    notes: >
        The element type is constrained to some type that CASTS all the given elements.
    see:
        - CASTS

MAPS_TO:
    syntax: >
        EXPRESSION {IC} ("→"|"->") {IC} EXPRESSION
    assoc: right
    doc: >
        function type builder

MEMBER_ACCESS:
    syntax: >
        EXPRESSION {IC} "." {IC} IDENTIFIER
    assoc: left

MEMBER_OFFSET:
    syntax: >
        "@" {IC} WHOLE_NUMBER

MODULATION:
    syntax: >
        EXPRESSION {IC} "%" {IC} EXPRESSION
    assoc: left
    precedes: [SUBTRACTION, ADDITION, ADD_SUB]
    doc: >
        mod operator or returns a collection containing the elements that would not be consumed from the end of the left hand side by taking the chunk of the right hand side

MODULATION_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} "%" ("<-"|"←") {IC} EXPRESSION
    doc: Modulate the two operands and assign the result to the first.
    see:
        - MODULATION

MULTIPLICATION:
    syntax: >
        EXPRESSION {IC} "*" {IC} EXPRESSION
    assoc: either
    precedes:
    doc: >
        scalar multiplication, cartesian product

MULTIPLICATION_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} "*" ("<-"|"←") {IC} EXPRESSION
    doc: Multiply the two operands and assign the result to the first.
    see:
        - MULTIPLICATION

MULTIPLICATIVE_OP:
    syntax: >
        CROSS_PRODUCT | DOT_PRODUCT | MULTIPLICATION
    precedes: [INTEGER_DIVISION, MAPS_TO, MODULATION, SUBTRACTION, ADDITION, ADD_SUB]

NAND:
    syntax: >
        EXPRESSION {IC} ("↑"|"nand") {IC} EXPRESSION
    assoc: left
    precedes: [OR, IMPLICATION, XOR, IFF]

NAND_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} ("↑"|"nand") ("<-"|"←") {IC} EXPRESSION
    doc: Nand the two operands and assign the result to the first.
    see:
        - NAND

NEAREST_INTEGER:
    syntax: >
        ( "⌊" {IC} EXPRESSION {IC} "⌉" ) | ("|_" {IC} EXPRESSION {IC} "'|" )
    doc: >
        round to the nearest integer

NEGATION:
    syntax: >
        "-" {IC} EXPRESSION
    precedes: [BINARY_OP]
    example: |
        -5

NEGATION_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} "-" ("<-"|"←")
    doc: Negate the operand and assign the result to it.
    see:
        - NEGATION

NON_FRACTIONAL:
    syntax: >
        ["-"] NON_NEG_NON_FRACTIONAL

NON_NEG_FRACTIONAL:
    syntax: >
        (decimal_digit {decimal_digit} "." {decimal_digit}) | ("." decimal_digit {decimal_digit})
    doc: >
        a number with a decimal point

NON_NEG_INTEGER:
    syntax: >
        (NON_ZERO_DECIMAL_DIGIT {decimal_digit}) | "0"
    notes: >
        The first digit may not be zero, unless it is the only digit.

NON_NEG_NON_FRACTIONAL:
    syntax: >
        NON_NEG_INTEGER | HEX | OCTAL

NON_NEG_NUMBER:
    syntax: >
        NON_NEG_NON_FRACTIONAL | NON_NEG_FRACTIONAL

NON_ZERO_DECIMAL_DIGIT:
    syntax: >
        "1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"
    doc: >
        used for constructing number

NOR:
    syntax: >
        EXPRESSION {IC} ("↓"|"nor") {IC} EXPRESSION
    assoc: left
    precedes: [OR, IMPLICATION, XOR, IFF]

NOR_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} ("↓"|"nor") ("<-"|"←") {IC} EXPRESSION
    doc: Nor the two operands and assign the result to the first.
    see:
        - NOR

NOT:
    syntax: >
        ("¬"|"~") {IC} EXPRESSION
    precedes: [BINARY_OP]
    doc: >
        boolean not

NOT_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} ("¬"|"~") ("<-"|"←")
    doc: Not the operand and assign the result to it.
    see:
        - NOT

NOT_HAS:
    syntax: >
        EXPRESSION {IC} ("∌"|"/has") {IC} EXPRESSION
    assoc: left
    doc: >
        not_in, backward

NOT_IN:
    syntax: >
        EXPRESSION {IC} ("∉"|"/in") {IC} EXPRESSION
    assoc: left
    doc: >
        Collection anti-membership

NULL_COALESCE:
    syntax: >
        EXPRESSION {IC} "??" {IC} EXPRESSION
    assoc: left
    doc: >
        return the first expression if non-null otherwise return the second expression
    notes: >
        may be chained together

NULL_COALESCE_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} "??" ("<-"|"←") {IC} EXPRESSION
    doc: Null coalesce the two operands and assign the result to the first.
    see:
        - NULL_COALESVE

OBJECT:
    syntax: >
        "object" {IC} ["inheriting" {IC} INHERITANCE_LIST {IC}] ["implementing" {IC} INHERITANCE_LIST {IC}] "{" TYPE_SCOPE "}"

OCTAL:
    syntax: >
        "0" octal_digit {octal_digit}
    doc: >
        octal number

OP_ASSIGNMENT:
    syntax: >
        ADD_SUB_ASSIGNMENT | ADDITION_ASSIGNMENT | AND_ASSIGNMENT | BIT_AND_ASSIGNMENT | BIT_NOT_ASSIGNMENT | BIT_OR_ASSIGNMENT | BIT_XOR_ASSIGNMENT | COMPOUND_ASSIGNMENT | COMPOSITION_ASSIGNMENT | CROSS_PRODUCT_ASSIGNMENT | DIVISION_ASSIGNMENT | EXPONENTIATION_ASSIGNMENT | FACTORIAL_ASSIGNMENT | IMPLICATION_ASSIGNMENT | INTEGER_DIVISION_ASSIGNMENT | INTERSECTION_ASSIGNMENT | MODULATION_ASSIGNMENT | MULTIPLICATION_ASSIGNMENT | NAND_ASSIGNMENT | NEGATION_ASSIGNMENT | NOR_ASSIGNMENT | NOT_ASSIGNMENT | NULL_COALESCE_ASSIGNMENT | OR_ASSIGNMENT | PRE_DEC | PRE_INC | PREPEND_ASSIGNMENT | POST_DEC | POST_INC | RADICAL_ASSIGNMENT | SHIFTL_ASSIGNMENT | SHIFTR_ASSIGNMENT | SUBTRACTION_ASSIGNMENT | SYMMETRIC_DIFFERENCE_ASSIGNMENT | UNION_ASSIGNMENT | XOR_ASSIGNMENT
    doc: Perform an operation on one or two operands and assign the result to the first.

OR:
    syntax: >
        EXPRESSION {IC} ("∨"|"or") {IC} EXPRESSION
    assoc: either
    precedes: [IMPLICATION, XOR, IFF]

OR_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} ("∨"|"or") ("<-"|"←") {IC} EXPRESSION
    doc: Or the two operands and assign the result to the first.
    see:
        - OR

PARAMETER:
    syntax: >
        PARAMETER_NATURAL | PARAMETER_ANALYTIC
    doc: >
        declares a formal argument of a function
    notes: >
        The last variation accepts an expression, which is then set to be equivalent to the passed in value. This enables pattern matching and solving on parameters.
    see:
        - FUNCTION

PARAMETER_ANALYTIC:
    syntax: >
        EXPRESSION [ {IC} "=" {IC} EXPRESSION ]

PARAMETER_NATURAL:
    syntax: >
        ([ TYPE_DEREFERENCE {IC} ] IDENTIFIER ["..."]) | ([ (TYPE_DEREFERENCE | IMPLICIT_TYPE_DEREFERENCE) {IC} ] IDENTIFIER ["..."] {IC} "=" {IC} EXPRESSION ["..."])
    precedes: [PARAMETER_ANALYTIC]

PARENTHETICAL:
    syntax: >
        "(" {IC} EXPRESSION {IC} ")"
    doc: >
        an expression in parenthesis
    example: |
        let result = (1 + 5) * 3;

PARENTHETICAL_INVOCATION:
    syntax: >
        %target(EXPRESSION) {IC} "(" %argsHead[{IC} (ARGUMENT|ARGUMENT_PACK)] %argsTail{{IC} "," [{IC} (ARGUMENT|ARGUMENT_PACK)]} {IC} ")"

PAYLOAD:
    syntax: >
        all { all }

PLATFORM:
    syntax: >
        "_" (letter | number) {letter | number | "_"}
    filter: longest
    see:
        - FUNCTION

POST_DEC:
    syntax: >
        EXPRESSION {IC} "--"
    precedes: [NEGATION, BINARY_OP]

POST_INC:
    syntax: >
        EXPRESSION {IC} "++"
    precedes: [NEGATION, BINARY_OP]

PRE_DEC:
    syntax: >
        "--" {IC} EXPRESSION
    precedes: [NEGATION, BINARY_OP]

PRE_INC:
    syntax: >
        "++" {IC} EXPRESSION
    precedes: [NEGATION, BINARY_OP]

PREPEND:
    syntax: >
        EXPRESSION {IC} "&" {IC} EXPRESSION
    assoc: right
    doc: >
        create a new Collection starting with the left hand side followed by the elements of the right hand side Collection
    example: >
        x := 1 & [2, 3, 4, 5];
        y := [1, 2, 3, 4, 5];
        x = y;

PREPEND_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} "&" ("<-"|"←") {IC} EXPRESSION
    doc: Prepend the second operand to the first and assign the result to the first.
    see:
        - PREPEND

RADICAL:
    syntax: >
        ("√"|"sqrt") {IC} EXPRESSION
    precedes: [DIVISION, INTEGER_DIVISION, MODULATION, MULTIPLICATIVE_OP, SUBTRACTION, ADDITION, ADD_SUB]

RADICAL_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} ("√"|"sqrt") ("<-"|"←")
    doc: Square root the operand and assign the result to it.
    see:
        - 

RANGE:
    syntax: >
        "(" {IC} "..." {IC} EXPRESSION {IC} ( "]" | ")" ) | ( "[" | "(" ) {IC} EXPRESSION {IC} "..." {IC} ")" | ( "(" | "[" ) {IC} EXPRESSION {IC} "..." {IC} EXPRESSION {IC} ( "]" | ")" )
    doc: >
        create a totally-ordered open/closed/half-open discreet/continuous Collection
    examples:
        - |
            wholeNumbers := [ 0 ... ); // the non negative integers - the set is infinite and denumerable
        - |
            positivesIntsToN := [ 1 ... n ]; // the integers 1 to n inclusive - the set is finite and denumerable
        - |
            negativeReals := ( ... 0.0 ) // the negative real numbers - the set is infinite and nondenumerable

READ_LOCK:
    syntax: >
        "read_lock" {IC} PARENTHETICAL {IC} EXPRESSION

RECORD:
    syntax: >
        "record" IC {IC} TYPE

REGEX:
    syntax: >
        "R" c_string

RELATIONAL_COLLECTION_OP:
    syntax: >
        HAS | IN | NOT_HAS | NOT_IN
    doc: >
        relational operators on collections

RELATIONAL_OP:
    syntax: >
        CASTS | DOWNCASTS | EXACTLY | IMPLEMENTS | INEQUALITY | INHERITS | IS | RELATIONAL_COLLECTION_OP | UPCASTS
    precedes: [BINARY_LOGICAL_OP]

RETURN:
    syntax: >
        "return" [{IC} "[" {IC} EXPRESSION {IC} "]"] [ {IC} EXPRESSION ]
    doc: >
        exit the current function, optionally returning a value
    notes: >
        if a square-bracketed value is appended to a the "return" keyword, that many scope levels plus one will return. "return" is the same as "return[0]".

SET:
    syntax: >
        "{|" {IC} %elements[EXPRESSION {{IC} "," {IC} EXPRESSION} {IC}] "|}"
    precedes: [MAGNITUDE]

SET_COMPREHENSION:
    syntax: >
        "{" {IC} EXPRESSION {IC} "|" {IC} EXPRESSION {IC} "}"
    doc: >
        create a Collection, substituting variables bound in the right hand side into the left hand side
    example: |
        { x | x ∈ ℝ ∧ x < 3 }

SHIFTL_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} "<<" ("<-"|"←") {IC} EXPRESSION
    doc: Shift the first operand left by the number of bits specified in the signed second operand and assign the result to the first.
    see:
        - SHIFTL

SHIFTL:
    syntax: >
        EXPRESSION {IC} "<<" {IC} EXPRESSION
    assoc: left
    doc: >
        shift left

SHIFTR_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} ">>" ("<-"|"←") {IC} EXPRESSION
    doc: Shift the first operand right by the number of bits specified in the signed second operand and assign the result to the first.
    see:
        - SHIFTR

SHIFTR:
    syntax: >
        EXPRESSION {IC} ">>" {IC} EXPRESSION
    assoc: left
    doc: >
        shift right

SLICE:
    syntax: >
        EXPRESSION {IC} ":" {IC} EXPRESSION
    doc: >
        used in ARRAY_INVOCATION

STATEMENT:
    syntax: >
        %value( ASSIGNMENT_CHAIN | BREAK | CONTINUE | DEFINITION | DO | EXPRESSION | FOR | FOR_COLLECTION | FREE | IMPORT | LOCK | LOOP | OP_ASSIGNMENT | READ_LOCK | RETURN | THROW | TRY | TYPE_CONSTRAINT | WRITE_LOCK | USING ) %ic{IC} ";"
    doc: >
        top-level statement syntax

STATEMENT_SCOPE:
    syntax: >
        {IC | STATEMENT}
    doc: >
        zero or more statements, the top level syntax rule for source files

STATIC:
    syntax: >
        "static"
    precedes: [IDENTIFIER] 

SUBSET_CHAIN:
    syntax: >
        EXPRESSION {IC} SUBSET_CHAIN_LOOP
    doc: >
        One or more subset, proper subset, or equality relations
    examples:
        - |
            S ⊂ T;
        - |
            S ⊆ T ⊂ U = V;

SUBSET_CHAIN_LOOP:
    syntax: >
        ("="|"⊆"|"subs"|"⊂"|"psubs") {IC} EXPRESSION [{IC} SUBSET_CHAIN_LOOP]
    precedes: [EXPRESSION]
    see:
        - SUBSET_CHAIN

SUBTRACTION_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} "-" ("<-"|"←") {IC} EXPRESSION
    doc: Subtract the two operands and assign the result to the first.
    see:
        - SUBTRACTION

SUBTRACTION:
    syntax: >
        EXPRESSION {IC} "-" {IC} EXPRESSION
    assoc: left

SUPERSET_CHAIN:
    syntax: >
        EXPRESSION {IC} SUPERSET_CHAIN_LOOP
    doc: >
        One or more superset, proper superset, or equality relations
    examples:
        - |
            S ⊃ T;
        - |
            S ⊇ T ⊃ U = V;

SUPERSET_CHAIN_LOOP:
    syntax: >
        ("="|"⊇"|"sups"|"⊃"|"psups") {IC} EXPRESSION [{IC} SUPERSET_CHAIN_LOOP]
    precedes: [EXPRESSION]
    see:
        - SUPERSET_CHAIN

SWIZZLE:
    syntax: >
        EXPRESSION {IC} ("⋮" | "_swiz_") {IC} EXPRESSION

SYMMETRIC_DIFFERENCE_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} "⊖" ("<-"|"←") {IC} EXPRESSION
    doc: Compute the unique elements in both operands and assign the result to the first.
    notes: >
        For cases where the subexpressions are Collections, DIVISION_ASSIGNMENT is semantically equivalent
    see:
        - SYMMETRIC_DIFFERENCE

SYMMETRIC_DIFFERENCE:
    syntax: >
        EXPRESSION {IC} "⊖" {IC} EXPRESSION
    assoc: left
    doc: >
        the set-theoretic symmetric difference (Collection xor)
    notes: >
        For cases where the subexpressions are Collections, DIVISION is semantically equivalent

THIS:
    syntax: >
        "this" [{IC} "[" {IC} EXPRESSION {IC} "]"]
      
THIS_FUNC:
    syntax: >
        "this_func" [{IC} "[" {IC} EXPRESSION {IC} "]"]
    
THIS_TYPE:
    syntax: >
        "this_type" [{IC} "[" {IC} EXPRESSION {IC} "]"]
    
THROW:
    syntax: >
        "throw" [{IC} "[" {IC} EXPRESSION {IC} "]" ] [{IC} EXPRESSION]
    doc: >
        raise an exception with an optional value which must implement Exception if specified
    notes: >
        if throw is followed by a square-bracketed expression, that many stack frames will unwind before throwing the exception. "throw" is the same as "throw[0]".
        
    see:
        - TRY

TIME:
    syntax: >
        ["-"] decimal_digit decimal_digit ":" decimal_digit decimal_digit ":" decimal_digit decimal_digit ["." decimal_digit {decimal_digit}] ["Z" | (("+"|"-") decimal_digit decimal_digit [":" decimal_digit decimal_digit])]

TRY:
    syntax: >
        "try" {IC} EXPRESSION {IC} "catch" {IC} EXPRESSION {"catch" {IC} EXPRESSION} [{IC} "finally" {IC} EXPRESSION]
    doc: >
        executes the specified nullary void function of the first expression, catching exceptions that pattern match the function(s) of the second expression, and then executes the third expression unconditionally

TUPLE:
    syntax: >
        "(|" {IC} EXPRESSION {{IC} "," {IC} EXPRESSION} {IC} "|)"
    precedes: [MAGNITUDE]
    doc: >
        create a finite, ordered tuple of elements

TYPE:
    syntax: >
        "type" {IC} ["inheriting" {IC} INHERITANCE_LIST {IC}] ["implementing" {IC} INHERITANCE_LIST {IC}] "{" TYPE_SCOPE "}"
    doc: >
        create a type
    example: |
        bank_account := type inheriting account {
            <float> balance @ 0;
        };

TYPE_CONSTRAINT:
    syntax: >
        TYPE_CONSTRAINT_HEAD {IC} TYPE_CONSTRAINT_CHAIN
    precedes: [EXPRESSION]

TYPE_CONSTRAINT_CHAIN:
    syntax: >
        (DECLARATION|ASSIGNMENT_CHAIN|DEFINITION) [{IC} "," {IC} TYPE_CONSTRAINT_CHAIN]

TYPE_CONSTRAINT_HEAD:
    syntax: >
        [$XML_DOC_STRING {IC}] {ATTRIBUTE {IC}} [$VISIBILITY_MODIFIER {IC}] [STATIC {IC}] [EXTERN {IC}] %type_dereference(TYPE_DEREFERENCE | VOLATILE_TYPE_DEREFERENCE | IMPLICIT_TYPE_DEREFERENCE | VOLATILE_IMPLICIT_TYPE_DEREFERENCE)

TYPE_DEREFERENCE:
    syntax: >
        "<" {IC} EXPRESSION {IC} ">"
    doc: >
        use a variable/constant as a typename

TYPE_INVOCATION:
    syntax: >
        %target(EXPRESSION) ( "<" %argsHead[{IC} (ARGUMENT|ARGUMENT_PACK)] %argsTail{{IC} "," [{IC} (ARGUMENT|ARGUMENT_PACK)]} {IC} ">" )

TYPE_SCOPE:
    syntax: >
        {IC} {TYPE_STATEMENT {IC}}
    doc: >
        zero or more statements or member declarations/definitions, used strictly in the TYPE syntax only
    notes: >
        Any use of the assignment operator indicates an instance member declaration. Any use of the definition operator indicates a static member of the class, since it is immutable it will not vary between instances. Like in statement_scope, an execution context is available and will execute any top-level statements inside the type.

TYPE_SCOPE_ASSIGNMENT_CHAIN:
    syntax: >
        [XML_DOC_STRING {IC}] IDENTIFIER [{IC} MEMBER_OFFSET] {IC} ("←"|"<-") {IC} (EXPRESSION|ASSIGNMENT_CHAIN)
    precedes: [EXPRESSION]

TYPE_SCOPE_DECLARATION:
    syntax: >
        [XML_DOC_STRING {IC}] IDENTIFIER [{IC} MEMBER_OFFSET]

TYPE_SCOPE_TYPE_CONSTRAINT:
    syntax: >
        TYPE_CONSTRAINT_HEAD {IC} TYPE_SCOPE_TYPE_CONSTRAINT_CHAIN
    precedes: [TYPE_CONSTRAINT]

TYPE_SCOPE_TYPE_CONSTRAINT_CHAIN:
    syntax: >
        [XML_DOC_STRING {IC}] (TYPE_SCOPE_DECLARATION|TYPE_SCOPE_ASSIGNMENT_CHAIN|DEFINITION) [{IC} "," {IC} TYPE_SCOPE_TYPE_CONSTRAINT_CHAIN]

TYPE_STATEMENT:
    syntax: >
        (VISIBILITY_MODIFIER {IC} ":") | TYPE_SCOPE_TYPE_CONSTRAINT | STATEMENT
    doc: >
        top-level type syntax

UNARY_ARITHMETIC_OP:
    syntax: >
        FACTORIAL | NEGATION | RADICAL

UNARY_LOGICAL_OP:
    syntax: >
        ALL | EXISTS | EXISTS_ONE | NOT
    precedes: [BINARY_LOGICAL_OP]

UNARY_OP:
    syntax: >
        ALLOCATION | CARDINALITY | KLEENE_STAR | UNARY_ARITHMETIC_OP | UNARY_LOGICAL_OP

UNION_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} "∪" ("<-"|"←") {IC} EXPRESSION
    doc: Union the two operands and assign the result to the first.
    see:
        - UNION

UNION:
    syntax: >
        EXPRESSION {IC} "∪" {IC} EXPRESSION
    assoc: either
    doc: >
        the set-theoretic union

UNIT_DIVISION:
    syntax: >
        DIMENSION "/" DIMENSION
    assoc: left
    doc: >
        dimensional analysis "per"
    see:
        - DIMENSIONAL_NUMBER

UNIT_EXPONENTIATION:
    syntax: >
        DIMENSION "^" NON_FRACTIONAL
    assoc: right
    precedes: [UNIT_MULTIPLICATION, UNIT_DIVISION]
    doc: >
        dimensional analysis square units, cubed units, etc
    see:
        - DIMENSIONAL_NUMBER

UNIT_MULTIPLICATION:
    syntax: >
        DIMENSION "*" DIMENSION
    assoc: left
    doc: >
        dimensional analysis "by"
    see:
        - DIMENSIONAL_NUMBER

UPCASTS:
    syntax: >
        EXPRESSION {IC} "upcasts" {IC} EXPRESSION
        
USING:
    syntax: >
        "using" {IC} "(" {IC} EXPRESSION {IC} ")" {IC} BLOCK
    doc: >
        values in the specified value are visible, and any value constructed inside the expression that is not visible from outside scopes, is destructed when the scope exits
        
VECTOR_NORM:
    syntax: >
        "||" {IC} EXPRESSION {IC} "||"
    doc: >
        create a Vector<D, N> normalized to unit length

VISIBILITY_MODIFIER:
    syntax: >
        ("public"|"protected"|"protected internal"|"internal"|"private")

VOLATILE_IMPLICIT_TYPE_DEREFERENCE:
    syntax: >
        "<" {IC} "volatile" {IC} ">"

VOLATILE_TYPE_DEREFERENCE:
    syntax: >
        "<" {IC} "volatile" {IC} EXPRESSION {IC} ">"

WHOLE_NUMBER:
    syntax: >
        ("1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9") {"0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"}
    see:
        - TYPE_SCOPE

WRITE_LOCK:
    syntax: >
        "write_lock" {IC} PARENTHETICAL {IC} EXPRESSION

WS:
    syntax: >
        white_space {white_space}
    filter: longest
    doc: >
        consumes whitespaces between other tokens

XML_DOC_STRING:
    syntax: >
        "```" XML_DOC_STRING_INTERIOR "```"
    doc: >
        documentation string bounded by arbirtrarily-sized delimiters

XML_DOC_STRING_INTERIOR:
    syntax: >
        $PAYLOAD | ("`" XML_DOC_STRING_INTERIOR "`")
    precedes: [PAYLOAD]

XOR_ASSIGNMENT:
    syntax: >
        EXPRESSION {IC} ("⊕" |"xor") ("<-"|"←") {IC} EXPRESSION
    doc: Xor the two operands and assign the result to the first.
    see:
        - XOR
XOR:
    syntax: >
        EXPRESSION {IC} ("⊕" |"xor") {IC} EXPRESSION
    assoc: left
